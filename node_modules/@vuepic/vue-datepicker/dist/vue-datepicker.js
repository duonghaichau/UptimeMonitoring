import { openBlock as y, createElementBlock as A, createElementVNode as L, defineComponent as Oe, ref as B, inject as ye, computed as C, unref as o, renderSlot as W, createCommentVNode as $, normalizeClass as fe, withKeys as ne, createBlock as re, withModifiers as He, reactive as Ht, onMounted as Ne, normalizeStyle as mt, Fragment as ie, createTextVNode as We, toDisplayString as ge, renderList as pe, createVNode as ze, Transition as yt, withCtx as le, nextTick as At, onBeforeUpdate as $a, onUnmounted as cn, mergeProps as Pe, createSlots as Ce, isRef as tt, normalizeProps as Ge, resolveDynamicComponent as Bt, useSlots as fn, withDirectives as Da, guardReactiveProps as nt, vShow as Ma, watch as St, getCurrentScope as Sa, onScopeDispose as Aa, toRef as Tt, provide as ct, Teleport as Pa } from "vue";
import { getMonth as ve, getYear as ue, isEqual as Yn, setHours as En, setMinutes as Fn, setSeconds as Hn, setMilliseconds as mn, isValid as Ot, setMonth as Nt, setYear as lt, getHours as _e, getMinutes as Be, getSeconds as je, format as Sn, isAfter as vn, isBefore as yn, set as Me, parseISO as Ca, parse as ln, isDate as Ta, add as Wn, sub as Ra, startOfWeek as Kn, endOfWeek as Va, addMonths as rt, getDay as _a, addDays as $t, subMonths as Dt, addYears as Ba, subYears as Oa, getISOWeek as Na, differenceInCalendarDays as Ia, eachDayOfInterval as An } from "date-fns";
const ot = (e, a) => {
  const n = e.__vccOpts || e;
  for (const [t, d] of a)
    n[t] = d;
  return n;
}, Ya = {}, Ea = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, Fa = /* @__PURE__ */ L("path", { d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z" }, null, -1), Ha = /* @__PURE__ */ L("path", { d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), Wa = /* @__PURE__ */ L("path", { d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), Ka = /* @__PURE__ */ L("path", { d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z" }, null, -1), Ua = [
  Fa,
  Ha,
  Wa,
  Ka
];
function La(e, a) {
  return y(), A("svg", Ea, Ua);
}
const Wt = /* @__PURE__ */ ot(Ya, [["render", La]]), Ga = {}, ja = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, za = /* @__PURE__ */ L("path", { d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z" }, null, -1), Xa = /* @__PURE__ */ L("path", { d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1), qa = [
  za,
  Xa
];
function Ja(e, a) {
  return y(), A("svg", ja, qa);
}
const Za = /* @__PURE__ */ ot(Ga, [["render", Ja]]), Qa = {}, xa = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, el = /* @__PURE__ */ L("path", { d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1), tl = [
  el
];
function nl(e, a) {
  return y(), A("svg", xa, tl);
}
const Pn = /* @__PURE__ */ ot(Qa, [["render", nl]]), al = {}, ll = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, rl = /* @__PURE__ */ L("path", { d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z" }, null, -1), sl = [
  rl
];
function ol(e, a) {
  return y(), A("svg", ll, sl);
}
const Cn = /* @__PURE__ */ ot(al, [["render", ol]]), il = {}, ul = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, dl = /* @__PURE__ */ L("path", { d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z" }, null, -1), cl = /* @__PURE__ */ L("path", { d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), fl = [
  dl,
  cl
];
function ml(e, a) {
  return y(), A("svg", ul, fl);
}
const Un = /* @__PURE__ */ ot(il, [["render", ml]]), vl = {}, yl = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, pl = /* @__PURE__ */ L("path", { d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1), hl = [
  pl
];
function gl(e, a) {
  return y(), A("svg", yl, hl);
}
const Ln = /* @__PURE__ */ ot(vl, [["render", gl]]), kl = {}, wl = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, bl = /* @__PURE__ */ L("path", { d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1), $l = [
  bl
];
function Dl(e, a) {
  return y(), A("svg", wl, $l);
}
const Gn = /* @__PURE__ */ ot(kl, [["render", Dl]]), Tn = (e, a) => {
  const n = ln(e, a.slice(0, e.length), new Date());
  return Ot(n) && Ta(n) ? n : null;
}, zt = (e, a) => {
  if (typeof a == "string")
    return Tn(e, a);
  if (Array.isArray(a)) {
    let n = null;
    for (let t = 0; t < a.length && (n = Tn(e, a[t]), !n); t++)
      ;
    return n;
  }
  return typeof a == "function" ? a(e) : null;
}, Fe = (e) => {
  let a = new Date(JSON.parse(JSON.stringify(e)));
  return a = En(a, 0), a = Fn(a, 0), a = Hn(a, 0), a = mn(a, 0), a;
}, rn = (e) => Array.isArray(e) ? Ot(e[0]) && (e[1] ? Ot(e[1]) : !0) : e ? Ot(e) : !1, Ae = (e, a, n, t) => {
  let d = e ? new Date(e) : new Date();
  return (a || a === 0) && (d = En(d, +a)), (n || n === 0) && (d = Fn(d, +n)), (t || t === 0) && (d = Hn(d, +t)), mn(d, 0);
}, Ml = (e) => {
  const a = rt(e, 1);
  return { month: ve(a), year: ue(a) };
}, st = (e, a, n) => {
  let t = e ? new Date(e) : new Date();
  return (a || a === 0) && (t = Nt(t, a)), n && (t = lt(t, n)), t;
}, Rn = (e, a) => e ? `HH:mm${a ? ":ss" : ""}` : `hh:mm${a ? ":ss" : ""} aa`, jn = (e, a, n, t, d, m, p, v) => e || (t ? "MM/yyyy" : d ? Rn(a, n) : m ? "MM/dd/yyyy" : p ? "yyyy" : v ? `MM/dd/yyyy, ${Rn(a, n)}` : "MM/dd/yyyy"), Xt = (e) => {
  const a = e || new Date();
  return {
    hours: _e(a),
    minutes: Be(a),
    seconds: je(a)
  };
}, It = (e) => ({ month: ve(e), year: ue(e) }), Vn = (e) => Array.isArray(e) ? [It(e[0]), e[1] ? It(e[1]) : null] : It(e), sn = (e) => Array.isArray(e) ? [Xt(e[0]), Xt(e[1])] : Xt(e), qt = (e, a, n) => n ? Sn(e, a, { locale: n }) : Sn(e, a), vt = (e, a, n, t, d) => Array.isArray(e) ? `${qt(e[0], a, n)} ${d && !e[1] ? "" : t || "-"} ${e[1] ? qt(e[1], a, n) : ""}` : qt(e, a, n), De = (e, a) => !e || !a ? !1 : vn(Fe(e), Fe(a)), we = (e, a) => !e || !a ? !1 : yn(Fe(e), Fe(a)), ce = (e, a) => !e || !a ? !1 : Yn(Fe(e), Fe(a)), Sl = (e, a) => Wn(Me(new Date(), e), a), Al = (e, a) => Ra(Me(new Date(), e), a), Jt = (e) => Me(new Date(), { hours: _e(e), minutes: Be(e), seconds: je(e) }), _n = (e) => Me(new Date(), {
  hours: +e.hours || 0,
  minutes: +e.minutes || 0,
  seconds: +e.seconds || 0
}), ft = (e, a, n, t) => {
  if (!e)
    return !0;
  if (t) {
    const d = n === "max" ? yn(e, a) : vn(e, a), m = { seconds: 0, milliseconds: 0 };
    return d || Yn(Me(e, m), Me(a, m));
  }
  return n === "max" ? e.getTime() <= a.getTime() : e.getTime() >= a.getTime();
}, on = (e, a, n, t, d) => {
  let m = !0;
  if (!e)
    return !0;
  const p = !d && !t ? Array.isArray(e) ? [e[0] ? Jt(e[0]) : null, e[1] ? Jt(e[1]) : null] : Jt(e) : e;
  if (a || t) {
    const v = a ? _n(a) : new Date(t);
    Array.isArray(p) ? m = ft(p[0], v, "max", !!t) && ft(p[1], v, "max", !!t) : m = ft(p, v, "max", !!t);
  }
  if (n || d) {
    const v = n ? _n(n) : new Date(d);
    Array.isArray(p) ? m = ft(p[0], v, "min", !!d) && ft(p[1], v, "min", !!d) && m : m = ft(p, v, "min", !!d) && m;
  }
  return m;
}, Pl = (e, a, n) => {
  let t = !0;
  return a && n && (t = De(new Date(e), new Date(a)) && we(new Date(e), new Date(n))), a && (t = De(new Date(e), new Date(a))), n && (t = we(new Date(e), new Date(n))), t;
}, Ee = (e) => e instanceof Date ? e : Ca(e), Zt = (e, a) => {
  if (a) {
    const t = new Date().getTimezoneOffset() * 6e4;
    return new Date(e.getTime() - t).toISOString();
  }
  const n = Date.UTC(
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate(),
    e.getUTCHours(),
    e.getUTCMinutes(),
    e.getUTCSeconds()
  );
  return new Date(n).toISOString();
}, zn = (e, a, n) => e && e[0] && e[1] ? De(n, e[0]) && we(n, e[1]) : e && e[0] && a ? De(n, e[0]) && we(n, a) || we(n, e[0]) && De(n, a) : !1, Rt = (e, a) => {
  const n = Kn(e, { weekStartsOn: a }), t = Va(e, { weekStartsOn: a });
  return [n, t];
}, Xn = (e, a) => Array.isArray(a) ? a.some((n) => ce(Ee(new Date(n)), Ee(e))) : a(e), Cl = (e, a, n, t, d, m, p, v) => {
  const g = n ? De(Ee(e), Ee(n)) : !1, w = a ? we(Ee(e), Ee(a)) : !1, V = Xn(e, t), E = (m.months.length ? m.months.map((l) => +l) : []).includes(ve(e)), N = p.length ? p.some((l) => +l === _a(e)) : !1, G = d.length ? !d.some((l) => ce(Ee(l), Ee(e))) : !1, T = ue(e), x = T < +v[0] || T > +v[1];
  return !(g || w || V || E || x || N || G);
}, qn = (e, a, n, t, d, m, p) => ({
  validate: (g) => Cl(g, e, a, n, t, d, m, p)
}), Xe = Symbol(), Kt = Symbol(), pn = Symbol(), Jn = Symbol(), Zn = Symbol(), qe = Symbol(), hn = {
  disabled: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  autoApply: { type: Boolean, default: !1 },
  inline: { type: Boolean, default: !1 },
  textInput: { type: Boolean, default: !1 }
}, gn = {
  range: { type: Boolean, default: !1 },
  uid: { type: String, default: null }
}, Qn = {
  enableSeconds: { type: Boolean, default: !1 },
  is24: { type: Boolean, default: !0 },
  noHoursOverlay: { type: Boolean, default: !1 },
  noMinutesOverlay: { type: Boolean, default: !1 },
  noSecondsOverlay: { type: Boolean, default: !1 },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 }
}, xn = {
  ...Qn,
  fixedStart: { type: Boolean, default: !1 },
  fixedEnd: { type: Boolean, default: !1 },
  timePicker: { type: Boolean, default: !1 }
}, ea = {
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: !1 },
  clearable: { type: Boolean, default: !0 },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: !1 },
  autocomplete: { type: String, default: "off" },
  inputClassName: { type: String, default: null },
  inlineWithInput: { type: Boolean, default: !1 },
  textInputOptions: { type: Object, default: () => null }
}, ta = {
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null }
}, kn = {
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null }
}, na = {
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: Boolean, default: !1 },
  partialRange: { type: Boolean, default: !0 },
  ignoreTimeValidation: { type: Boolean, default: !1 },
  ...ta
}, wn = {
  monthPicker: { type: Boolean, default: !1 },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: !1 },
  modelAuto: { type: Boolean, default: !1 }
}, aa = {
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: { type: Boolean, default: !1 },
  calendarClassName: { type: String, default: null },
  noSwipe: { type: Boolean, default: !1 },
  monthChangeOnScroll: { type: [Boolean, String], default: !0 },
  dayNames: {
    type: [Function, Array],
    default: null
  }
}, la = {
  ...xn,
  ...na,
  ...wn,
  ...kn,
  ...aa,
  ...gn,
  vertical: { type: Boolean, default: !1 },
  disableMonthYearSelect: { type: Boolean, default: !1 },
  menuClassName: { type: String, default: null },
  yearRange: { type: Array, default: () => [1900, 2100] },
  multiCalendarsSolo: { type: Boolean, default: !1 },
  calendarCellClassName: { type: String, default: null },
  enableTimePicker: { type: Boolean, default: !0 },
  autoApply: { type: Boolean, default: !1 },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  monthYearComponent: { type: Object, default: null },
  timePickerComponent: { type: Object, default: null },
  actionRowComponent: { type: Object, default: null },
  hideOffsetDates: { type: Boolean, default: !1 },
  autoRange: { type: [Number, String], default: null },
  noToday: { type: Boolean, default: !1 },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: () => [] },
  showNowButton: { type: Boolean, default: !1 },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  modeHeight: { type: [Number, String], default: 255 },
  escClose: { type: Boolean, default: !0 },
  spaceConfirm: { type: Boolean, default: !0 },
  monthChangeOnArrows: { type: Boolean, default: !0 },
  presetRanges: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  preventMinMaxNavigation: { type: Boolean, default: !1 },
  minRange: { type: [Number, String], default: null },
  maxRange: { type: [Number, String], default: null },
  multiDatesLimit: { type: [Number, String], default: null },
  reverseYears: { type: Boolean, default: !1 },
  keepActionRow: { type: Boolean, default: !1 },
  weekPicker: { type: Boolean, default: !1 },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: !1 },
  multiStatic: { type: Boolean, default: !0 },
  disableTimeRangeValidation: { type: Boolean, default: !1 },
  highlight: {
    type: [Array, Function],
    default: null
  },
  highlightWeekDays: {
    type: Array,
    default: null
  },
  teleportCenter: { type: Boolean, default: !1 }
}, Tl = {
  ...ea,
  ...hn,
  ...la,
  multiCalendars: { type: [Boolean, Number, String], default: null },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: !1 },
  format: {
    type: [String, Function],
    default: () => null
  },
  closeOnScroll: { type: Boolean, default: !1 },
  autoPosition: { type: Boolean, default: !0 },
  closeOnAutoApply: { type: Boolean, default: !0 },
  teleport: { type: [String, Object], default: "body" },
  altPosition: { type: [Boolean, Function], default: !1 },
  transitions: { type: [Boolean, Object], default: !0 },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: !1 },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 }
}, ra = {
  range: { type: Boolean, default: !1 },
  multiCalendars: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null }
}, sa = {
  ...wn,
  ...ra,
  vertical: { type: Boolean, default: !1 },
  month: { type: Number, default: 0 },
  year: { type: Number, default: 0 },
  instance: { type: Number, default: 1 }
}, Rl = ["aria-label", "aria-disabled", "aria-readonly"], Vl = {
  key: 1,
  class: "dp__input_wrap"
}, _l = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "onKeydown"], Bl = {
  key: 2,
  class: "dp__input_icon"
}, Ol = {
  key: 4,
  class: "dp__clear_icon"
}, Nl = /* @__PURE__ */ Oe({
  __name: "DatepickerInput",
  props: {
    ...ea,
    ...hn,
    ...gn,
    inputValue: { type: String, default: "" },
    inline: { type: Boolean, default: !1 },
    isMenuOpen: { type: Boolean, default: !1 },
    pattern: { type: String, default: "" }
  },
  emits: [
    "clear",
    "open",
    "update:inputValue",
    "setInputDate",
    "close",
    "selectDate",
    "setEmptyDate",
    "toggle",
    "focus-prev",
    "focus",
    "blur"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, d = B(), m = B(null), p = B(!1), v = ye(Xe), g = C(
      () => ({
        dp__pointer: !t.disabled && !t.readonly && !t.textInput,
        dp__disabled: t.disabled,
        dp__input_readonly: !t.textInput,
        dp__input: !0,
        dp__input_icon_pad: !t.hideInputIcon,
        dp__input_valid: t.state,
        dp__input_invalid: t.state === !1,
        dp__input_focus: p.value || t.isMenuOpen,
        dp__input_reg: !t.textInput,
        [t.inputClassName]: !!t.inputClassName
      })
    ), w = (i) => {
      var K;
      const { value: Y } = i.target, { format: z, rangeSeparator: P } = t.textInputOptions;
      if (Y !== "") {
        if (((K = t.textInputOptions) == null ? void 0 : K.openMenu) && !t.isMenuOpen && n("open"), t.range) {
          const [X, ee] = Y.split(`${P}`);
          if (X && ee) {
            const Z = zt(X.trim(), z || t.pattern), j = zt(ee.trim(), z || t.pattern);
            d.value = Z && j ? [Z, j] : null;
          }
        } else
          d.value = zt(Y, z || t.pattern);
        n("setInputDate", d.value);
      } else
        n("setInputDate", null), t.autoApply && (n("setEmptyDate"), d.value = null);
      n("update:inputValue", Y);
    }, V = () => {
      var i, Y;
      ((i = t.textInputOptions) == null ? void 0 : i.enterSubmit) && rn(d.value) && t.inputValue !== "" ? (n("setInputDate", d.value, !0), d.value = null) : ((Y = t.textInputOptions) == null ? void 0 : Y.enterSubmit) && t.inputValue === "" && (d.value = null, n("clear"));
    }, R = () => {
      var i, Y;
      ((i = t.textInputOptions) == null ? void 0 : i.tabSubmit) && rn(d.value) && t.inputValue !== "" ? (n("setInputDate", d.value, !0), d.value = null) : ((Y = t.textInputOptions) == null ? void 0 : Y.tabSubmit) && t.inputValue === "" && (d.value = null, n("clear"));
    }, E = () => {
      p.value = !0, n("focus");
    }, N = (i) => {
      var Y;
      i.preventDefault(), i.stopImmediatePropagation(), i.stopPropagation(), t.textInput && ((Y = t.textInputOptions) == null ? void 0 : Y.openMenu) ? t.isMenuOpen ? t.textInputOptions.enterSubmit && n("selectDate") : n("open") : t.textInput || n("toggle");
    }, G = () => {
      p.value = !1, t.isMenuOpen || n("blur"), t.autoApply && t.textInput && d.value && (n("setInputDate", d.value), n("selectDate"), d.value = null);
    }, T = () => {
      n("clear");
    }, x = (i) => {
      t.textInput || i.preventDefault();
    };
    return a({
      focusInput: () => {
        m.value && m.value.focus({ preventScroll: !0 });
      }
    }), (i, Y) => (y(), A("div", {
      onClick: N,
      "aria-label": o(v).input,
      role: "textbox",
      "aria-multiline": "false",
      "aria-disabled": i.disabled,
      "aria-readonly": i.readonly
    }, [
      i.$slots.trigger && !i.$slots["dp-input"] && !e.inline ? W(i.$slots, "trigger", { key: 0 }) : $("", !0),
      !i.$slots.trigger && (!e.inline || i.inlineWithInput) ? (y(), A("div", Vl, [
        i.$slots["dp-input"] && !i.$slots.trigger && !e.inline ? W(i.$slots, "dp-input", {
          key: 0,
          value: e.inputValue,
          onInput: w,
          onEnter: V,
          onTab: R,
          onClear: T
        }) : $("", !0),
        i.$slots["dp-input"] ? $("", !0) : (y(), A("input", {
          key: 1,
          ref_key: "inputRef",
          ref: m,
          id: i.uid ? `dp-input-${i.uid}` : void 0,
          name: i.name,
          class: fe(o(g)),
          inputmode: i.textInput ? "text" : "none",
          placeholder: i.placeholder,
          disabled: i.disabled,
          readonly: i.readonly,
          required: i.required,
          value: e.inputValue,
          autocomplete: i.autocomplete,
          onInput: w,
          onKeydown: [
            ne(N, ["enter"]),
            ne(R, ["tab"])
          ],
          onBlur: G,
          onFocus: E,
          onKeypress: x
        }, null, 42, _l)),
        i.$slots["input-icon"] && !i.hideInputIcon ? (y(), A("span", Bl, [
          W(i.$slots, "input-icon")
        ])) : $("", !0),
        !i.$slots["input-icon"] && !i.hideInputIcon && !i.$slots["dp-input"] ? (y(), re(o(Wt), {
          key: 3,
          class: "dp__input_icon dp__input_icons"
        })) : $("", !0),
        i.$slots["clear-icon"] && e.inputValue && i.clearable && !i.disabled && !i.readonly ? (y(), A("span", Ol, [
          W(i.$slots, "clear-icon", { clear: T })
        ])) : $("", !0),
        i.clearable && !i.$slots["clear-icon"] && e.inputValue && !i.disabled && !i.readonly ? (y(), re(o(Za), {
          key: 5,
          class: "dp__clear_icon dp__input_icons",
          onClick: He(T, ["stop", "prevent"])
        }, null, 8, ["onClick"])) : $("", !0)
      ])) : $("", !0)
    ], 8, Rl));
  }
}), Il = (e) => typeof e == "object", Bn = (e, a) => a, Yl = (e) => Array.isArray(e) && e.length === 2, El = (e) => Array.isArray(e), Fl = (e) => typeof e == "object", bt = (e) => Array.isArray(e), Ve = (e) => Array.isArray(e), Yt = (e) => Array.isArray(e) && e.length === 2, Hl = (e, a) => a ? Array.isArray(e) : Yt(e), Wl = (e) => Array.isArray(e), Kl = (e) => typeof e == "string" || typeof e == "object" || typeof e == "number", On = (e) => typeof e == "string", de = Ht({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
}), Qt = B(null), Vt = B(!1), xt = B(!1), en = B(!1), tn = B(!1), $e = B(0), he = B(0), Je = () => {
  const e = C(() => Vt.value ? [...de.selectionGrid, de.actionRow].filter((l) => l.length) : xt.value ? [
    ...de.timePicker[0],
    ...de.timePicker[1],
    tn.value ? [] : [Qt.value],
    de.actionRow
  ].filter((l) => l.length) : en.value ? [...de.monthPicker, de.actionRow] : [de.monthYear, ...de.calendar, de.time, de.actionRow].filter((l) => l.length)), a = (l) => {
    $e.value = l ? $e.value + 1 : $e.value - 1;
    let i = null;
    e.value[he.value] && (i = e.value[he.value][$e.value]), i || ($e.value = l ? $e.value - 1 : $e.value + 1);
  }, n = (l) => {
    if (he.value === 0 && !l || he.value === e.value.length && l)
      return;
    he.value = l ? he.value + 1 : he.value - 1, e.value[he.value] ? e.value[he.value] && !e.value[he.value][$e.value] && $e.value !== 0 && ($e.value = e.value[he.value].length - 1) : he.value = l ? he.value - 1 : he.value + 1;
  }, t = (l) => {
    let i = null;
    e.value[he.value] && (i = e.value[he.value][$e.value]), i ? i.focus({ preventScroll: !Vt.value }) : $e.value = l ? $e.value - 1 : $e.value + 1;
  }, d = () => {
    a(!0), t(!0);
  }, m = () => {
    a(!1), t(!1);
  }, p = () => {
    n(!1), t(!0);
  }, v = () => {
    n(!0), t(!0);
  }, g = (l, i) => {
    de[i] = l;
  }, w = (l, i) => {
    de[i] = l;
  }, V = () => {
    $e.value = 0, he.value = 0;
  };
  return {
    buildMatrix: g,
    buildMultiLevelMatrix: w,
    setTimePickerBackRef: (l) => {
      Qt.value = l;
    },
    setSelectionGrid: (l) => {
      Vt.value = l, V(), l || (de.selectionGrid = []);
    },
    setTimePicker: (l, i = !1) => {
      xt.value = l, tn.value = i, V(), l || (de.timePicker[0] = [], de.timePicker[1] = []);
    },
    setTimePickerElements: (l, i = 0) => {
      de.timePicker[i] = l;
    },
    arrowRight: d,
    arrowLeft: m,
    arrowUp: p,
    arrowDown: v,
    clearArrowNav: () => {
      de.monthYear = [], de.calendar = [], de.time = [], de.actionRow = [], de.selectionGrid = [], de.timePicker[0] = [], de.timePicker[1] = [], Vt.value = !1, xt.value = !1, tn.value = !1, en.value = !1, V(), Qt.value = null;
    },
    setMonthPicker: (l) => {
      en.value = l, V();
    }
  };
}, Ul = (e, a, n) => {
  const t = new Date(JSON.parse(JSON.stringify(e))), d = [];
  for (let m = 0; m < 7; m++) {
    const p = $t(t, m), v = ve(p) !== a;
    d.push({
      text: n && v ? "" : p.getDate(),
      value: p,
      current: !v
    });
  }
  return d;
}, Ll = (e, a, n, t) => {
  const d = [], m = new Date(a, e), p = new Date(a, e + 1, 0), v = Kn(m, { weekStartsOn: n }), g = (w) => {
    const V = Ul(w, e, t);
    if (d.push({ days: V }), !d[d.length - 1].days.some((R) => ce(Fe(R.value), Fe(p)))) {
      const R = $t(w, 7);
      g(R);
    }
  };
  return g(v), d;
}, Gl = (e, a = 3) => {
  const n = [];
  for (let t = 0; t < e.length; t += a)
    n.push([e[t], e[t + 1], e[t + 2]]);
  return n;
}, jl = (e, a) => {
  const n = [1, 2, 3, 4, 5, 6, 7].map((m) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(new Date(`2017-01-0${m}T00:00:00+00:00`)).slice(0, 2)), t = n.slice(0, a), d = n.slice(a + 1, n.length);
  return [n[a]].concat(...d).concat(...t);
}, zl = (e) => {
  const a = [];
  for (let n = +e[0]; n <= +e[1]; n++)
    a.push({ value: +n, text: `${n}` });
  return a;
}, Xl = (e, a) => {
  const n = new Intl.DateTimeFormat(e, { month: a, timeZone: "UTC" });
  return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((d) => {
    const m = d < 10 ? `0${d}` : d;
    return new Date(`2017-${m}-01T00:00:00+00:00`);
  }).map((d, m) => ({
    text: n.format(d),
    value: m
  }));
}, ql = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e], Jl = () => ({
  enterSubmit: !0,
  tabSubmit: !0,
  openMenu: !0,
  rangeSeparator: " - "
}), Zl = (e) => Object.assign({ months: [], years: [], times: { hours: [], minutes: [], seconds: [] } }, e), Ql = (e) => {
  function n(t) {
    let d = "";
    const m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", p = m.length;
    for (let v = 0; v < t; v++)
      d += m.charAt(Math.floor(Math.random() * p));
    return d + e;
  }
  return n(5);
}, ke = (e) => {
  var n;
  const a = o(e);
  return (n = a == null ? void 0 : a.$el) != null ? n : a;
}, xl = (e) => Object.assign({ type: "dot" }, e), Nn = (e) => Object.assign(
  {
    menuAppear: "dp-menu-appear",
    open: "dp-slide-down",
    close: "dp-slide-up",
    next: "calendar-next",
    previous: "calendar-prev",
    vNext: "dp-slide-up",
    vPrevious: "dp-slide-down"
  },
  e
), er = (e) => Object.assign(
  {
    toggleOverlay: "Toggle overlay",
    menu: "Datepicker menu",
    input: "Datepicker input",
    calendarWrap: "Calendar wrapper",
    calendarDays: "Calendar days",
    openTimePicker: "Open time picker",
    closeTimePicker: "Close time Picker",
    incrementValue: (a) => `Increment ${a}`,
    decrementValue: (a) => `Decrement ${a}`,
    openTpOverlay: (a) => `Open ${a} overlay`,
    amPmButton: "Switch AM/PM mode",
    openYearsOverlay: "Open years overlay",
    openMonthsOverlay: "Open months overlay",
    nextMonth: "Next month",
    prevMonth: "Previous month"
  },
  e
), oa = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : !1, tr = { class: "dp__selection_preview" }, nr = { class: "dp__action_buttons" }, ar = ["onKeydown"], lr = /* @__PURE__ */ Oe({
  __name: "ActionRow",
  props: {
    ...na,
    ...kn,
    ...ta,
    ...wn,
    ...ra,
    inline: { type: Boolean, default: !1 },
    timePicker: { type: Boolean, default: !1 },
    calendarWidth: { type: Number, default: 0 },
    menuMount: { type: Boolean, default: !1 },
    enableTimePicker: { type: Boolean, default: !0 }
  },
  emits: ["closePicker", "selectDate", "invalid-select"],
  setup(e, { emit: a }) {
    const n = e, { buildMatrix: t } = Je(), d = ye(Zn), m = ye(qe), p = B(null), v = B(null);
    Ne(() => {
      m != null && m.value && t([ke(p), ke(v)], "actionRow");
    });
    const g = C(() => n.range && !n.partialRange && n.internalModelValue ? n.internalModelValue.length === 2 : !0), w = C(() => ({
      dp__action: !0,
      dp__select: !0,
      dp__action_disabled: !V.value || !R.value || !g.value
    })), V = C(() => !n.enableTimePicker || n.ignoreTimeValidation ? !0 : on(n.internalModelValue, n.maxTime, n.minTime, n.maxDate, n.minDate)), R = C(() => n.monthPicker ? Pl(n.internalModelValue, n.minDate, n.maxDate) : !0), E = (T) => vt(T, n.previewFormat, d == null ? void 0 : d.value), N = C(() => !n.internalModelValue || !n.menuMount ? "" : typeof n.previewFormat == "string" ? bt(n.internalModelValue) ? n.internalModelValue.length === 2 && n.internalModelValue[1] ? n.multiCalendars > 0 ? `${E(n.internalModelValue[0])} - ${E(
      n.internalModelValue[1]
    )}` : [E(n.internalModelValue[0]), E(n.internalModelValue[1])] : n.multiDates ? n.internalModelValue.map((T) => `${E(T)}`) : n.modelAuto ? `${E(n.internalModelValue[0])}` : `${E(n.internalModelValue[0])} -` : vt(n.internalModelValue, n.previewFormat, d == null ? void 0 : d.value) : n.timePicker ? n.previewFormat(sn(n.internalModelValue)) : n.monthPicker ? n.previewFormat(It(n.internalModelValue)) : n.previewFormat(n.internalModelValue)), G = () => {
      V.value && R.value && g.value ? a("selectDate") : a("invalid-select");
    };
    return (T, x) => (y(), A("div", {
      class: "dp__action_row",
      style: mt(e.calendarWidth ? { width: `${e.calendarWidth}px` } : {})
    }, [
      L("div", tr, [
        T.$slots["action-preview"] ? W(T.$slots, "action-preview", {
          key: 0,
          value: T.internalModelValue
        }) : $("", !0),
        T.$slots["action-preview"] ? $("", !0) : (y(), A(ie, { key: 1 }, [
          Array.isArray(o(N)) ? $("", !0) : (y(), A(ie, { key: 0 }, [
            We(ge(o(N)), 1)
          ], 64)),
          Array.isArray(o(N)) ? (y(!0), A(ie, { key: 1 }, pe(o(N), (l, i) => (y(), A("div", { key: i }, ge(l), 1))), 128)) : $("", !0)
        ], 64))
      ]),
      L("div", nr, [
        T.$slots["action-select"] ? W(T.$slots, "action-select", {
          key: 0,
          value: T.internalModelValue
        }) : $("", !0),
        T.$slots["action-select"] ? $("", !0) : (y(), A(ie, { key: 1 }, [
          e.inline ? $("", !0) : (y(), A("span", {
            key: 0,
            class: "dp__action dp__cancel",
            ref_key: "cancelButtonRef",
            ref: p,
            tabindex: "0",
            onClick: x[0] || (x[0] = (l) => T.$emit("closePicker")),
            onKeydown: [
              x[1] || (x[1] = ne((l) => T.$emit("closePicker"), ["enter"])),
              x[2] || (x[2] = ne((l) => T.$emit("closePicker"), ["space"]))
            ]
          }, ge(T.cancelText), 545)),
          L("span", {
            class: fe(o(w)),
            tabindex: "0",
            onKeydown: [
              ne(G, ["enter"]),
              ne(G, ["space"])
            ],
            onClick: G,
            ref_key: "selectButtonRef",
            ref: v
          }, ge(T.selectText), 43, ar)
        ], 64))
      ])
    ], 4));
  }
}), rr = ["aria-label"], sr = {
  class: "dp__calendar_header",
  role: "row"
}, or = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
}, ir = /* @__PURE__ */ L("div", { class: "dp__calendar_header_separator" }, null, -1), ur = ["aria-label"], dr = {
  key: 0,
  role: "gridcell",
  class: "dp__calendar_item dp__week_num"
}, cr = { class: "dp__cell_inner" }, fr = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"], mr = /* @__PURE__ */ L("div", { class: "dp__arrow_bottom_tp" }, null, -1), vr = /* @__PURE__ */ Oe({
  __name: "Calendar",
  props: {
    ...sa,
    ...aa,
    mappedDates: { type: Array, default: () => [] },
    getWeekNum: {
      type: Function,
      default: () => ""
    },
    modeHeight: { type: [Number, String], default: 255 },
    specificMode: { type: Boolean, default: !1 }
  },
  emits: ["selectDate", "setHoverDate", "handleScroll", "mount", "handleSwipe", "handleSpace"],
  setup(e, { expose: a, emit: n }) {
    const t = e, d = B(null), m = B({ bottom: "", left: "", transform: "" }), p = B([]), v = B(null), g = B(!0), w = ye(Kt), V = ye(Xe), R = ye(qe), E = B(""), N = B({ startX: 0, endX: 0, startY: 0, endY: 0 }), G = C(() => t.dayNames ? Array.isArray(t.dayNames) ? t.dayNames : t.dayNames(t.locale, +t.weekStart) : jl(t.locale, +t.weekStart)), { buildMultiLevelMatrix: T } = Je();
    Ne(() => {
      n("mount", { cmp: "calendar", refs: p }), t.noSwipe || v.value && (v.value.addEventListener("touchstart", ee, { passive: !1 }), v.value.addEventListener("touchend", Z, { passive: !1 }), v.value.addEventListener("touchmove", j, { passive: !1 })), t.monthChangeOnScroll && v.value && v.value.addEventListener("wheel", u, { passive: !1 });
    });
    const x = (s, h) => {
      if (w != null && w.value) {
        const F = Fe(st(new Date(), t.month, t.year));
        E.value = De(Fe(st(new Date(), s, h)), F) ? w.value[t.vertical ? "vNext" : "next"] : w.value[t.vertical ? "vPrevious" : "previous"], g.value = !1, At(() => {
          g.value = !0;
        });
      }
    }, l = C(
      () => ({
        dp__calendar_wrap: !0,
        [t.calendarClassName]: !!t.calendarClassName
      })
    ), i = C(() => (s) => {
      const h = xl(s);
      return {
        dp__marker_dot: h.type === "dot",
        dp__marker_line: h.type === "line"
      };
    }), Y = C(() => (s) => ce(s, d.value)), z = C(() => ({
      dp__calendar: !0,
      dp__calendar_next: t.multiCalendars > 0 && t.instance !== 0
    })), P = C(() => t.specificMode ? { height: `${t.modeHeight}px` } : null), K = (s, h, F) => {
      var J, I;
      if (n("setHoverDate", s), (I = (J = s.marker) == null ? void 0 : J.tooltip) != null && I.length) {
        const oe = ke(p.value[h][F]);
        if (oe) {
          const { width: te, height: k } = oe.getBoundingClientRect();
          m.value = {
            bottom: `${k}px`,
            left: `${te / 2}px`,
            transform: "translateX(-50%)"
          }, d.value = s.value;
        }
      }
    }, X = () => {
      d.value = null;
    }, ee = (s) => {
      N.value.startX = s.changedTouches[0].screenX, N.value.startY = s.changedTouches[0].screenY;
    }, Z = (s) => {
      N.value.endX = s.changedTouches[0].screenX, N.value.endY = s.changedTouches[0].screenY, M();
    }, j = (s) => {
      s.preventDefault();
    }, M = () => {
      const s = t.vertical ? "Y" : "X";
      Math.abs(N.value[`start${s}`] - N.value[`end${s}`]) > 10 && n("handleSwipe", N.value[`start${s}`] > N.value[`end${s}`] ? "right" : "left");
    }, D = (s, h, F) => {
      s && (Array.isArray(p.value[h]) ? p.value[h][F] = s : p.value[h] = [s]), R != null && R.value && T(p.value, "calendar");
    }, u = (s) => {
      t.monthChangeOnScroll && (s.preventDefault(), n("handleScroll", s));
    };
    return a({ triggerTransition: x }), (s, h) => (y(), A("div", {
      class: fe(o(z))
    }, [
      L("div", {
        style: mt(o(P))
      }, [
        e.specificMode ? $("", !0) : (y(), A("div", {
          key: 0,
          ref_key: "calendarWrapRef",
          ref: v,
          class: fe(o(l)),
          role: "grid",
          "aria-label": o(V).calendarWrap
        }, [
          L("div", sr, [
            s.weekNumbers ? (y(), A("div", or, ge(s.weekNumName), 1)) : $("", !0),
            (y(!0), A(ie, null, pe(o(G), (F, J) => (y(), A("div", {
              class: "dp__calendar_header_item",
              role: "gridcell",
              key: J
            }, [
              s.$slots["calendar-header"] ? W(s.$slots, "calendar-header", {
                key: 0,
                day: F,
                index: J
              }) : $("", !0),
              s.$slots["calendar-header"] ? $("", !0) : (y(), A(ie, { key: 1 }, [
                We(ge(F), 1)
              ], 64))
            ]))), 128))
          ]),
          ir,
          ze(yt, {
            name: E.value,
            css: !!o(w)
          }, {
            default: le(() => [
              g.value ? (y(), A("div", {
                key: 0,
                class: "dp__calendar",
                role: "grid",
                "aria-label": o(V).calendarDays
              }, [
                (y(!0), A(ie, null, pe(e.mappedDates, (F, J) => (y(), A("div", {
                  class: "dp__calendar_row",
                  role: "row",
                  key: J
                }, [
                  s.weekNumbers ? (y(), A("div", dr, [
                    L("div", cr, ge(e.getWeekNum(F.days)), 1)
                  ])) : $("", !0),
                  (y(!0), A(ie, null, pe(F.days, (I, oe) => (y(), A("div", {
                    role: "gridcell",
                    class: "dp__calendar_item",
                    ref_for: !0,
                    ref: (te) => D(te, J, oe),
                    key: oe + J,
                    "aria-selected": I.classData.dp__active_date || I.classData.dp__range_start || I.classData.dp__range_start,
                    "aria-disabled": I.classData.dp__cell_disabled,
                    tabindex: "0",
                    onClick: He((te) => s.$emit("selectDate", I), ["stop", "prevent"]),
                    onKeydown: [
                      ne((te) => s.$emit("selectDate", I), ["enter"]),
                      ne((te) => s.$emit("handleSpace", I), ["space"])
                    ],
                    onMouseover: (te) => K(I, J, oe),
                    onMouseleave: X
                  }, [
                    L("div", {
                      class: fe(["dp__cell_inner", I.classData])
                    }, [
                      s.$slots.day ? W(s.$slots, "day", {
                        key: 0,
                        day: +I.text,
                        date: I.value
                      }) : $("", !0),
                      s.$slots.day ? $("", !0) : (y(), A(ie, { key: 1 }, [
                        We(ge(I.text), 1)
                      ], 64)),
                      I.marker ? (y(), A("div", {
                        key: 2,
                        class: fe(o(i)(I.marker)),
                        style: mt(I.marker.color ? { backgroundColor: I.marker.color } : {})
                      }, null, 6)) : $("", !0),
                      o(Y)(I.value) ? (y(), A("div", {
                        key: 3,
                        class: "dp__marker_tooltip",
                        style: mt(m.value)
                      }, [
                        L("div", {
                          class: "dp__tooltip_content",
                          onClick: h[0] || (h[0] = He(() => {
                          }, ["stop"]))
                        }, [
                          (y(!0), A(ie, null, pe(I.marker.tooltip, (te, k) => (y(), A("div", {
                            key: k,
                            class: "dp__tooltip_text"
                          }, [
                            s.$slots["marker-tooltip"] ? W(s.$slots, "marker-tooltip", {
                              key: 0,
                              tooltop: te,
                              day: I.value
                            }) : $("", !0),
                            s.$slots["marker-tooltip"] ? $("", !0) : (y(), A(ie, { key: 1 }, [
                              L("div", {
                                class: "dp__tooltip_mark",
                                style: mt(te.color ? { backgroundColor: te.color } : {})
                              }, null, 4),
                              L("div", null, ge(te.text), 1)
                            ], 64))
                          ]))), 128)),
                          mr
                        ])
                      ], 4)) : $("", !0)
                    ], 2)
                  ], 40, fr))), 128))
                ]))), 128))
              ], 8, ur)) : $("", !0)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ], 10, rr))
      ], 4)
    ], 2));
  }
}), yr = ["aria-label", "aria-disabled"], nn = /* @__PURE__ */ Oe({
  __name: "ActionIcon",
  props: {
    ariaLabel: { type: String, default: "" },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["activate", "setRef"],
  setup(e, { emit: a }) {
    const n = B(null);
    return Ne(() => a("setRef", n)), (t, d) => (y(), A("div", {
      class: "dp__month_year_col_nav",
      onClick: d[0] || (d[0] = (m) => t.$emit("activate")),
      onKeydown: [
        d[1] || (d[1] = ne((m) => t.$emit("activate"), ["enter"])),
        d[2] || (d[2] = ne((m) => t.$emit("activate"), ["space"]))
      ],
      tabindex: "0",
      role: "button",
      "aria-label": e.ariaLabel,
      "aria-disabled": e.disabled,
      ref_key: "elRef",
      ref: n
    }, [
      L("div", {
        class: fe(["dp__inner_nav", { dp__inner_nav_disabled: e.disabled }])
      }, [
        W(t.$slots, "default")
      ], 2)
    ], 40, yr));
  }
}), pr = { class: "dp__selection_grid_header" }, hr = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"], gr = ["aria-label", "onKeydown"], Mt = /* @__PURE__ */ Oe({
  __name: "SelectionGrid",
  props: {
    items: { type: Array, default: () => [] },
    modelValue: { type: [String, Number], default: null },
    multiModelValue: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: [Number, String], default: null },
    maxValue: { type: [Number, String], default: null },
    year: { type: Number, default: 0 },
    skipActive: { type: Boolean, default: !1 },
    headerRefs: { type: Array, default: () => [] },
    skipButtonRef: { type: Boolean, default: !1 },
    monthPicker: { type: Boolean, default: !1 },
    yearPicker: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue", "selected", "toggle", "reset-flow"],
  setup(e, { expose: a, emit: n }) {
    const t = e, d = B(!1), m = B(null), p = B(null), v = B([]), g = ye(pn, !1), w = ye(Jn, B(!1)), V = ye(Xe), R = ye(qe), E = B(), N = B(), { setSelectionGrid: G, buildMultiLevelMatrix: T, setMonthPicker: x } = Je();
    $a(() => {
      m.value = null;
    }), Ne(() => {
      At().then(() => Z()), i(), l(!0);
    }), cn(() => l(!1));
    const l = (s) => {
      var h;
      R != null && R.value && ((h = t.headerRefs) != null && h.length ? x(s) : G(s));
    }, i = () => {
      const s = ke(p);
      s && (w.value || s.focus({ preventScroll: !0 }), d.value = s.clientHeight < s.scrollHeight);
    }, Y = C(
      () => ({
        dp__overlay: !0
      })
    ), z = C(() => ({
      dp__overlay_col: !0
    })), P = C(() => t.items.map((s) => s.filter((h) => h).map((h) => {
      var I, oe, te;
      const F = t.disabledValues.some((k) => k === h.value) || ee(h.value), J = (I = t.multiModelValue) != null && I.length ? (oe = t.multiModelValue) == null ? void 0 : oe.some(
        (k) => ce(
          k,
          lt(
            t.monthPicker ? Nt(new Date(), h.value) : new Date(),
            t.monthPicker ? t.year : h.value
          )
        )
      ) : t.skipActive ? !1 : h.value === t.modelValue;
      return {
        ...h,
        className: {
          dp__overlay_cell_active: J,
          dp__overlay_cell: !J,
          dp__overlay_cell_disabled: F,
          dp__overlay_cell_active_disabled: F && J,
          dp__overlay_cell_pad: !0,
          dp__cell_in_between: (te = t.multiModelValue) != null && te.length ? M(h.value) : !1
        }
      };
    }))), K = C(
      () => ({
        dp__button: !0,
        dp__overlay_action: !0,
        dp__over_action_scroll: d.value,
        dp__button_bottom: g
      })
    ), X = C(() => {
      var s, h;
      return {
        dp__overlay_container: !0,
        dp__container_flex: ((s = t.items) == null ? void 0 : s.length) <= 6,
        dp__container_block: ((h = t.items) == null ? void 0 : h.length) > 6
      };
    }), ee = (s) => {
      const h = t.maxValue || t.maxValue === 0, F = t.minValue || t.minValue === 0;
      return !h && !F ? !1 : h && F ? +s > +t.maxValue || +s < +t.minValue : h ? +s > +t.maxValue : F ? +s < +t.minValue : !1;
    }, Z = () => {
      const s = ke(m);
      if (s) {
        const h = ke(p);
        h && (h.scrollTop = s.offsetTop - h.offsetTop - (h.getBoundingClientRect().height / 2 - s.getBoundingClientRect().height));
      }
    }, j = (s) => {
      !t.disabledValues.some((h) => h === s) && !ee(s) && (n("update:modelValue", s), n("selected"));
    }, M = (s) => {
      const h = t.monthPicker ? t.year : s;
      return zn(
        t.multiModelValue,
        lt(
          t.monthPicker ? Nt(new Date(), E.value || 0) : new Date(),
          t.monthPicker ? h : E.value || h
        ),
        lt(t.monthPicker ? Nt(new Date(), s) : new Date(), h)
      );
    }, D = () => {
      n("toggle"), n("reset-flow");
    }, u = (s, h, F, J) => {
      var I, oe;
      if (s && (h.value === +t.modelValue && !t.disabledValues.includes(h.value) && (m.value = s), R != null && R.value)) {
        Array.isArray(v.value[F]) ? v.value[F][J] = s : v.value[F] = [s];
        const te = (I = t.headerRefs) != null && I.length ? [t.headerRefs].concat(v.value) : v.value.concat([t.skipButtonRef ? [] : [N.value]]);
        T(te, (oe = t.headerRefs) != null && oe.length ? "monthPicker" : "selectionGrid");
      }
    };
    return a({ focusGrid: i }), (s, h) => (y(), A("div", {
      ref_key: "gridWrapRef",
      ref: p,
      class: fe(o(Y)),
      role: "dialog",
      tabindex: "0"
    }, [
      L("div", {
        class: fe(o(X)),
        role: "grid"
      }, [
        L("div", pr, [
          W(s.$slots, "header")
        ]),
        (y(!0), A(ie, null, pe(o(P), (F, J) => (y(), A("div", {
          class: "dp__overlay_row",
          key: o(Ql)(J),
          role: "row"
        }, [
          (y(!0), A(ie, null, pe(F, (I, oe) => (y(), A("div", {
            role: "gridcell",
            class: fe(o(z)),
            key: I.value,
            "aria-selected": I.value === e.modelValue && !e.disabledValues.includes(I.value),
            "aria-disabled": I.className.dp__overlay_cell_disabled,
            ref_for: !0,
            ref: (te) => u(te, I, J, oe),
            tabindex: "0",
            onClick: (te) => j(I.value),
            onKeydown: [
              ne((te) => j(I.value), ["enter"]),
              ne((te) => j(I.value), ["space"])
            ],
            onMouseover: (te) => E.value = I.value
          }, [
            L("div", {
              class: fe(I.className)
            }, [
              s.$slots.item ? W(s.$slots, "item", {
                key: 0,
                item: I
              }) : $("", !0),
              s.$slots.item ? $("", !0) : (y(), A(ie, { key: 1 }, [
                We(ge(I.text), 1)
              ], 64))
            ], 2)
          ], 42, hr))), 128))
        ]))), 128)),
        s.$slots["button-icon"] ? (y(), A("div", {
          key: 0,
          role: "button",
          "aria-label": o(V).toggleOverlay,
          class: fe(o(K)),
          tabindex: "0",
          ref_key: "toggleButton",
          ref: N,
          onClick: D,
          onKeydown: ne(D, ["enter"])
        }, [
          W(s.$slots, "button-icon")
        ], 42, gr)) : $("", !0)
      ], 2)
    ], 2));
  }
}), Ut = () => {
  const e = ye(Kt);
  return { transitionName: C(() => (n) => e != null && e.value ? n ? e.value.open : e.value.close : ""), showTransition: !!(e != null && e.value) };
}, kr = ["aria-label"], In = /* @__PURE__ */ Oe({
  __name: "RegularPicker",
  props: {
    ariaLabel: { type: String, default: "" },
    showSelectionGrid: { type: Boolean, default: !1 },
    modelValue: { type: Number, default: null },
    items: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: Number, default: null },
    maxValue: { type: Number, default: null },
    slotName: { type: String, default: "" },
    headerRefs: { type: Array, default: () => [] }
  },
  emits: ["update:model-value", "toggle", "setRef"],
  setup(e, { emit: a }) {
    const { transitionName: n, showTransition: t } = Ut(), d = B(null);
    return Ne(() => a("setRef", d)), (m, p) => (y(), A(ie, null, [
      L("div", {
        class: "dp__month_year_select",
        onClick: p[0] || (p[0] = (v) => m.$emit("toggle")),
        onKeydown: [
          p[1] || (p[1] = ne((v) => m.$emit("toggle"), ["enter"])),
          p[2] || (p[2] = ne((v) => m.$emit("toggle"), ["space"]))
        ],
        role: "button",
        "aria-label": e.ariaLabel,
        tabindex: "0",
        ref_key: "elRef",
        ref: d
      }, [
        W(m.$slots, "default")
      ], 40, kr),
      ze(yt, {
        name: o(n)(e.showSelectionGrid),
        css: o(t)
      }, {
        default: le(() => [
          e.showSelectionGrid ? (y(), re(Mt, Pe({ key: 0 }, {
            modelValue: e.modelValue,
            items: e.items,
            disabledValues: e.disabledValues,
            minValue: e.minValue,
            maxValue: e.maxValue
          }, {
            "header-refs": [],
            "onUpdate:modelValue": p[3] || (p[3] = (v) => m.$emit("update:model-value", v)),
            onToggle: p[4] || (p[4] = (v) => m.$emit("toggle"))
          }), Ce({
            "button-icon": le(() => [
              m.$slots["calendar-icon"] ? W(m.$slots, "calendar-icon", { key: 0 }) : $("", !0),
              m.$slots["calendar-icon"] ? $("", !0) : (y(), re(o(Wt), { key: 1 }))
            ]),
            _: 2
          }, [
            m.$slots[e.slotName] ? {
              name: "item",
              fn: le(({ item: v }) => [
                W(m.$slots, e.slotName, { item: v })
              ]),
              key: "0"
            } : void 0
          ]), 1040)) : $("", !0)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ], 64));
  }
}), Ft = (e, a, n) => [Me(new Date(e), { date: 1 }), Me(new Date(), { month: a, year: n, date: 1 })], un = (e, a, n) => we(...Ft(e, a, n)) || ce(...Ft(e, a, n)), dn = (e, a, n) => De(...Ft(e, a, n)) || ce(...Ft(e, a, n)), ia = (e, a, n, t, d, m) => {
  let p = !1;
  return m ? e && a ? (a && d && dn(a, n, t) && (p = !0), e && !d && un(e, n, t) && (p = !0)) : (e && un(e, n, t) || a && dn(a, n, t)) && (p = !0) : p = !0, p;
}, wr = (e, a) => {
  const n = (v, g) => {
    let w = v;
    return e.filters.months.includes(ve(w)) ? (w = g ? rt(v, 1) : Dt(v, 1), n(w, g)) : w;
  }, t = (v, g) => {
    let w = v;
    return e.filters.years.includes(ue(w)) ? (w = g ? Ba(v, 1) : Oa(v, 1), t(w, g)) : w;
  }, d = (v) => {
    const g = Me(new Date(), { month: e.month, year: e.year });
    let w = v ? rt(g, 1) : Dt(g, 1), V = ve(w), R = ue(w);
    e.filters.months.includes(V) && (w = n(w, v), V = ve(w), R = ue(w)), e.filters.years.includes(R) && (w = t(w, v), R = ue(w)), ia(e.minDate, e.maxDate, V, R, v, e.preventMinMaxNavigation) && m(V, R);
  }, m = (v, g) => {
    a("update-month-year", { month: v, year: g });
  }, p = C(() => (v) => {
    if (!e.preventMinMaxNavigation || v && !e.maxDate || !v && !e.minDate)
      return !1;
    const g = Me(new Date(), { month: e.month, year: e.year }), w = v ? rt(g, 1) : Dt(g, 1), V = [ve(w), ue(w)];
    return v ? !dn(e.maxDate, ...V) : !un(e.minDate, ...V);
  });
  return { handleMonthYearChange: d, isDisabled: p };
}, br = { class: "dp__month_year_row" }, $r = { class: "dp__month_picker_header" }, Dr = ["aria-label"], Mr = ["aria-label", "onKeydown"], Sr = ["aria-label"], Ar = /* @__PURE__ */ Oe({
  __name: "MonthYearPicker",
  props: {
    ...sa,
    ...kn,
    preventMinMaxNavigation: { type: Boolean, default: !1 },
    reverseYears: { type: Boolean, default: !1 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    filters: { type: Object, default: () => ({}) },
    multiCalendarsSolo: { type: Boolean, default: !1 },
    yearPicker: { type: Boolean, default: !1 }
  },
  emits: ["update-month-year", "monthYearSelect", "mount", "reset-flow", "overlay-closed"],
  setup(e, { expose: a, emit: n }) {
    const t = e, { transitionName: d, showTransition: m } = Ut(), { buildMatrix: p } = Je(), v = B(!1), g = B(!1), w = B([null, null, null, null]), V = B(null), R = B(null), E = B(null), N = ye(Xe), G = ye(qe), { handleMonthYearChange: T, isDisabled: x } = wr(t, n);
    Ne(() => {
      n("mount");
    });
    const l = (k) => ({
      get: () => t[k],
      set: (_) => {
        const O = k === "month" ? "year" : "month";
        n("update-month-year", { [k]: _, [O]: t[O] }), n("monthYearSelect", k === "year"), k === "month" ? F(!0) : J(!0);
      }
    }), i = C(l("month")), Y = C(l("year")), z = C(() => (k) => {
      const _ = k === "month";
      return {
        showSelectionGrid: (_ ? v : g).value,
        items: (_ ? D : u).value,
        disabledValues: t.filters[_ ? "months" : "years"],
        minValue: (_ ? X : P).value,
        maxValue: (_ ? ee : K).value,
        headerRefs: _ && t.monthPicker ? [V.value, R.value, E.value] : []
      };
    }), P = C(() => t.minDate ? ue(new Date(t.minDate)) : null), K = C(() => t.maxDate ? ue(new Date(t.maxDate)) : null), X = C(() => {
      if (t.minDate && P.value) {
        if (P.value > t.year)
          return 12;
        if (P.value === t.year)
          return ve(new Date(t.minDate));
      }
      return null;
    }), ee = C(() => t.maxDate && K.value ? K.value < t.year ? -1 : K.value === t.year ? ve(new Date(t.maxDate)) : null : null), Z = C(() => t.range && t.internalModelValue && (t.monthPicker || t.yearPicker) ? t.internalModelValue : []), j = (k, _ = !1) => {
      const O = [];
      for (let Re = 0; Re < k.length; Re += 3) {
        const Ie = [k[Re], k[Re + 1], k[Re + 2]];
        O.push(_ ? Ie.reverse() : Ie);
      }
      return _ ? O.reverse() : O;
    }, M = C(() => {
      const k = t.months.find((_) => _.value === t.month);
      return k || { text: "", value: 0 };
    }), D = C(() => j(t.months)), u = C(() => j(t.years, t.reverseYears)), s = C(() => t.multiCalendars ? t.multiCalendarsSolo ? !0 : t.instance === 0 : !0), h = C(() => t.multiCalendars ? t.multiCalendarsSolo ? !0 : t.instance === t.multiCalendars - 1 : !0), F = (k = !1) => {
      I(k), v.value = !v.value, v.value || n("overlay-closed");
    }, J = (k = !1) => {
      I(k), g.value = !g.value, g.value || n("overlay-closed");
    }, I = (k) => {
      k || n("reset-flow");
    }, oe = (k = !1) => {
      n("update-month-year", { year: k ? t.year + 1 : t.year - 1, month: t.month });
    }, te = (k, _) => {
      G != null && G.value && (w.value[_] = ke(k), p(w.value, "monthYear"));
    };
    return a({
      toggleMonthPicker: F,
      toggleYearPicker: J
    }), (k, _) => (y(), A("div", br, [
      !k.monthPicker && !e.yearPicker ? (y(), A(ie, { key: 0 }, [
        o(s) && !k.vertical ? (y(), re(nn, {
          key: 0,
          "aria-label": o(N).prevMonth,
          disabled: o(x)(!1),
          onActivate: _[0] || (_[0] = (O) => o(T)(!1)),
          onSetRef: _[1] || (_[1] = (O) => te(O, 0))
        }, {
          default: le(() => [
            k.$slots["arrow-left"] ? W(k.$slots, "arrow-left", { key: 0 }) : $("", !0),
            k.$slots["arrow-left"] ? $("", !0) : (y(), re(o(Pn), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label", "disabled"])) : $("", !0),
        ze(In, Pe({
          "aria-label": o(N).openMonthsOverlay,
          "slot-name": "month-overlay",
          modelValue: o(i),
          "onUpdate:modelValue": _[2] || (_[2] = (O) => tt(i) ? i.value = O : null)
        }, o(z)("month"), {
          onToggle: F,
          onSetRef: _[3] || (_[3] = (O) => te(O, 1))
        }), Ce({
          default: le(() => [
            k.$slots.month ? W(k.$slots, "month", Ge(Pe({ key: 0 }, o(M)))) : $("", !0),
            k.$slots.month ? $("", !0) : (y(), A(ie, { key: 1 }, [
              We(ge(o(M).text), 1)
            ], 64))
          ]),
          _: 2
        }, [
          k.$slots["calendar-icon"] ? {
            name: "calendar-icon",
            fn: le(() => [
              W(k.$slots, "calendar-icon")
            ]),
            key: "0"
          } : void 0,
          k.$slots["month-overlay"] ? {
            name: "month-overlay",
            fn: le(({ item: O }) => [
              W(k.$slots, "month-overlay", {
                text: O.text,
                value: O.value
              })
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["aria-label", "modelValue"]),
        ze(In, Pe({
          "aria-label": o(N).openYearsOverlay,
          "slot-name": "year-overlay",
          modelValue: o(Y),
          "onUpdate:modelValue": _[4] || (_[4] = (O) => tt(Y) ? Y.value = O : null)
        }, o(z)("year"), {
          onToggle: J,
          onSetRef: _[5] || (_[5] = (O) => te(O, 2))
        }), Ce({
          default: le(() => [
            k.$slots.year ? W(k.$slots, "year", {
              key: 0,
              year: k.year
            }) : $("", !0),
            k.$slots.year ? $("", !0) : (y(), A(ie, { key: 1 }, [
              We(ge(k.year), 1)
            ], 64))
          ]),
          _: 2
        }, [
          k.$slots["calendar-icon"] ? {
            name: "calendar-icon",
            fn: le(() => [
              W(k.$slots, "calendar-icon")
            ]),
            key: "0"
          } : void 0,
          k.$slots["year-overlay"] ? {
            name: "year-overlay",
            fn: le(({ item: O }) => [
              W(k.$slots, "year-overlay", {
                text: O.text,
                value: O.value
              })
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["aria-label", "modelValue"]),
        o(s) && k.vertical ? (y(), re(nn, {
          key: 1,
          "aria-label": o(N).prevMonth,
          disabled: o(x)(!1),
          onActivate: _[6] || (_[6] = (O) => o(T)(!1))
        }, {
          default: le(() => [
            k.$slots["arrow-up"] ? W(k.$slots, "arrow-up", { key: 0 }) : $("", !0),
            k.$slots["arrow-up"] ? $("", !0) : (y(), re(o(Ln), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label", "disabled"])) : $("", !0),
        o(h) ? (y(), re(nn, {
          key: 2,
          disabled: o(x)(!0),
          "aria-label": o(N).nextMonth,
          onActivate: _[7] || (_[7] = (O) => o(T)(!0)),
          ref: "rightIcon",
          onSetRef: _[8] || (_[8] = (O) => te(O, 3))
        }, {
          default: le(() => [
            k.$slots[k.vertical ? "arrow-down" : "arrow-right"] ? W(k.$slots, k.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : $("", !0),
            k.$slots[k.vertical ? "arrow-down" : "arrow-right"] ? $("", !0) : (y(), re(Bt(k.vertical ? o(Gn) : o(Cn)), { key: 1 }))
          ]),
          _: 3
        }, 8, ["disabled", "aria-label"])) : $("", !0)
      ], 64)) : $("", !0),
      k.monthPicker ? (y(), re(Mt, Pe({ key: 1 }, o(z)("month"), {
        "skip-active": t.range,
        year: k.year,
        "multi-model-value": o(Z),
        "month-picker": "",
        modelValue: o(i),
        "onUpdate:modelValue": _[15] || (_[15] = (O) => tt(i) ? i.value = O : null),
        onToggle: F,
        onSelected: _[16] || (_[16] = (O) => k.$emit("overlay-closed"))
      }), Ce({
        header: le(() => [
          L("div", $r, [
            L("div", {
              class: "dp__month_year_col_nav",
              tabindex: "0",
              ref_key: "mpPrevIconRef",
              ref: V,
              onClick: _[9] || (_[9] = (O) => oe(!1)),
              onKeydown: _[10] || (_[10] = ne((O) => oe(!1), ["enter"]))
            }, [
              L("div", {
                class: "dp__inner_nav",
                role: "button",
                "aria-label": o(N).prevMonth
              }, [
                k.$slots["arrow-left"] ? W(k.$slots, "arrow-left", { key: 0 }) : $("", !0),
                k.$slots["arrow-left"] ? $("", !0) : (y(), re(o(Pn), { key: 1 }))
              ], 8, Dr)
            ], 544),
            L("div", {
              class: "dp__pointer",
              role: "button",
              ref_key: "mpYearButtonRef",
              ref: R,
              "aria-label": o(N).openYearsOverlay,
              tabindex: "0",
              onClick: J,
              onKeydown: ne(J, ["enter"])
            }, [
              k.$slots.year ? W(k.$slots, "year", {
                key: 0,
                year: k.year
              }) : $("", !0),
              k.$slots.year ? $("", !0) : (y(), A(ie, { key: 1 }, [
                We(ge(k.year), 1)
              ], 64))
            ], 40, Mr),
            L("div", {
              class: "dp__month_year_col_nav",
              tabindex: "0",
              ref_key: "mpNextIconRef",
              ref: E,
              onClick: _[11] || (_[11] = (O) => oe(!0)),
              onKeydown: _[12] || (_[12] = ne((O) => oe(!0), ["enter"]))
            }, [
              L("div", {
                class: "dp__inner_nav",
                role: "button",
                "aria-label": o(N).nextMonth
              }, [
                k.$slots["arrow-right"] ? W(k.$slots, "arrow-right", { key: 0 }) : $("", !0),
                k.$slots["arrow-right"] ? $("", !0) : (y(), re(o(Cn), { key: 1 }))
              ], 8, Sr)
            ], 544)
          ]),
          ze(yt, {
            name: o(d)(g.value),
            css: o(m)
          }, {
            default: le(() => [
              g.value ? (y(), re(Mt, Pe({ key: 0 }, o(z)("year"), {
                modelValue: o(Y),
                "onUpdate:modelValue": _[13] || (_[13] = (O) => tt(Y) ? Y.value = O : null),
                onToggle: J,
                onSelected: _[14] || (_[14] = (O) => k.$emit("overlay-closed"))
              }), Ce({
                "button-icon": le(() => [
                  k.$slots["calendar-icon"] ? W(k.$slots, "calendar-icon", { key: 0 }) : $("", !0),
                  k.$slots["calendar-icon"] ? $("", !0) : (y(), re(o(Wt), { key: 1 }))
                ]),
                _: 2
              }, [
                k.$slots["year-overlay"] ? {
                  name: "item",
                  fn: le(({ item: O }) => [
                    W(k.$slots, "year-overlay", {
                      text: O.text,
                      value: O.value
                    })
                  ]),
                  key: "0"
                } : void 0
              ]), 1040, ["modelValue"])) : $("", !0)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ]),
        _: 2
      }, [
        k.$slots["month-overlay"] ? {
          name: "item",
          fn: le(({ item: O }) => [
            W(k.$slots, "month-overlay", {
              text: O.text,
              value: O.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1040, ["skip-active", "year", "multi-model-value", "modelValue"])) : $("", !0),
      e.yearPicker ? (y(), re(Mt, Pe({ key: 2 }, o(z)("year"), {
        modelValue: o(Y),
        "onUpdate:modelValue": _[17] || (_[17] = (O) => tt(Y) ? Y.value = O : null),
        "multi-model-value": o(Z),
        "skip-active": t.range,
        "skip-button-ref": "",
        "year-picker": "",
        onToggle: J,
        onSelected: _[18] || (_[18] = (O) => k.$emit("overlay-closed"))
      }), Ce({ _: 2 }, [
        k.$slots["year-overlay"] ? {
          name: "item",
          fn: le(({ item: O }) => [
            W(k.$slots, "year-overlay", {
              text: O.text,
              value: O.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1040, ["modelValue", "multi-model-value", "skip-active"])) : $("", !0)
    ]));
  }
}), Pr = {
  key: 0,
  class: "dp__time_input"
}, Cr = /* @__PURE__ */ We(" : "), Tr = ["aria-label", "onKeydown", "onClick"], Rr = ["aria-label", "onKeydown", "onClick"], Vr = ["aria-label", "onKeydown", "onClick"], _r = { key: 0 }, Br = ["aria-label", "onKeydown"], Or = /* @__PURE__ */ Oe({
  __name: "TimeInput",
  props: {
    ...Qn,
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    filters: { type: Object, default: () => ({}) },
    disabled: { type: Boolean, default: !1 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 }
  },
  emits: [
    "setHours",
    "setMinutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, d = Ht({
      hours: !1,
      minutes: !1,
      seconds: !1
    }), m = B("AM"), p = B(null), v = ye(Xe), g = ye(qe), w = B([]), { transitionName: V, showTransition: R } = Ut(), { setTimePickerElements: E, setTimePickerBackRef: N } = Je();
    Ne(() => {
      n("mounted");
    });
    const G = C(
      () => ({
        dp__time_col: !0,
        dp__time_col_reg: !t.enableSeconds && t.is24,
        dp__time_col_reg_with_button: !t.enableSeconds && !t.is24,
        dp__time_col_sec: t.enableSeconds && t.is24,
        dp__time_col_sec_with_button: t.enableSeconds && !t.is24
      })
    ), T = C(() => {
      const M = [{ type: "hours" }, "separator", { type: "minutes" }];
      return t.enableSeconds ? M.concat(["separator", { type: "seconds" }]) : M;
    }), x = C(() => T.value.filter((M) => typeof M != "string")), l = C(() => (M) => {
      if (M === "hours") {
        const D = K(t.hours);
        return { text: D < 10 ? `0${D}` : `${D}`, value: D };
      }
      return { text: t[M] < 10 ? `0${t[M]}` : `${t[M]}`, value: t[M] };
    }), i = (M) => {
      const D = M === "hours" ? t.is24 ? 24 : 12 : 60, u = +t[`${M}GridIncrement`], s = [];
      for (let h = 0; h < D; h += u)
        s.push({ value: h, text: h < 10 ? `0${h}` : `${h}` });
      return Gl(s);
    }, Y = (M) => t[`no${M[0].toUpperCase() + M.slice(1)}Overlay`], z = (M) => {
      Y(M) || (d[M] = !d[M], d[M] || n("overlay-closed"));
    }, P = (M, D = !0) => {
      const u = M === "hours" ? _e : M === "minutes" ? Be : je, s = D ? Sl : Al;
      n(`update:${M}`, u(s({ [M]: +t[M] }, { [M]: +t[`${M}Increment`] })));
    }, K = (M) => t.is24 ? M : (M >= 12 ? m.value = "PM" : m.value = "AM", ql(M)), X = () => {
      m.value === "PM" ? (m.value = "AM", n("update:hours", t.hours - 12)) : (m.value = "PM", n("update:hours", t.hours + 12));
    }, ee = (M) => {
      d[M] = !0;
    }, Z = (M, D, u) => {
      if (M && (g == null ? void 0 : g.value)) {
        Array.isArray(w.value[D]) ? w.value[D][u] = M : w.value[D] = [M];
        const s = w.value.reduce(
          (h, F) => F.map((J, I) => [...h[I] || [], F[I]]),
          []
        );
        N(t.closeTimePickerBtn), p.value && (s[1] = s[1].concat(p.value)), E(s, t.order);
      }
    }, j = (M, D) => M === "hours" && !t.is24 ? n(`update:${M}`, m.value === "PM" ? D + 12 : D) : n(`update:${M}`, D);
    return a({ openChildCmp: ee }), (M, D) => e.disabled ? $("", !0) : (y(), A("div", Pr, [
      (y(!0), A(ie, null, pe(o(T), (u, s) => (y(), A("div", {
        key: s,
        class: fe(o(G))
      }, [
        u === "separator" ? (y(), A(ie, { key: 0 }, [
          Cr
        ], 64)) : (y(), A(ie, { key: 1 }, [
          L("div", {
            class: "dp__inc_dec_button",
            role: "button",
            "aria-label": o(v).incrementValue(u.type),
            tabindex: "0",
            onKeydown: [
              ne((h) => P(u.type), ["enter"]),
              ne((h) => P(u.type), ["space"])
            ],
            onClick: (h) => P(u.type),
            ref_for: !0,
            ref: (h) => Z(h, s, 0)
          }, [
            M.$slots["arrow-up"] ? W(M.$slots, "arrow-up", { key: 0 }) : $("", !0),
            M.$slots["arrow-up"] ? $("", !0) : (y(), re(o(Ln), { key: 1 }))
          ], 40, Tr),
          L("div", {
            role: "button",
            "aria-label": o(v).openTpOverlay(u.type),
            class: fe(Y(u.type) ? "" : "dp__time_display"),
            tabindex: "0",
            onKeydown: [
              ne((h) => z(u.type), ["enter"]),
              ne((h) => z(u.type), ["space"])
            ],
            onClick: (h) => z(u.type),
            ref_for: !0,
            ref: (h) => Z(h, s, 1)
          }, [
            M.$slots[u.type] ? W(M.$slots, u.type, {
              key: 0,
              text: o(l)(u.type).text,
              value: o(l)(u.type).value
            }) : $("", !0),
            M.$slots[u.type] ? $("", !0) : (y(), A(ie, { key: 1 }, [
              We(ge(o(l)(u.type).text), 1)
            ], 64))
          ], 42, Rr),
          L("div", {
            class: "dp__inc_dec_button",
            role: "button",
            "aria-label": o(v).decrementValue(u.type),
            tabindex: "0",
            onKeydown: [
              ne((h) => P(u.type, !1), ["enter"]),
              ne((h) => P(u.type, !1), ["space"])
            ],
            onClick: (h) => P(u.type, !1),
            ref_for: !0,
            ref: (h) => Z(h, s, 2)
          }, [
            M.$slots["arrow-down"] ? W(M.$slots, "arrow-down", { key: 0 }) : $("", !0),
            M.$slots["arrow-down"] ? $("", !0) : (y(), re(o(Gn), { key: 1 }))
          ], 40, Vr)
        ], 64))
      ], 2))), 128)),
      M.is24 ? $("", !0) : (y(), A("div", _r, [
        M.$slots["am-pm-button"] ? W(M.$slots, "am-pm-button", {
          key: 0,
          toggle: X,
          value: m.value
        }) : $("", !0),
        M.$slots["am-pm-button"] ? $("", !0) : (y(), A("button", {
          key: 1,
          ref_key: "amPmButton",
          ref: p,
          type: "button",
          class: "dp__pm_am_button",
          role: "button",
          "aria-label": o(v).amPmButton,
          tabindex: "0",
          onClick: X,
          onKeydown: [
            ne(He(X, ["prevent"]), ["enter"]),
            ne(He(X, ["prevent"]), ["space"])
          ]
        }, ge(m.value), 41, Br))
      ])),
      (y(!0), A(ie, null, pe(o(x), (u, s) => (y(), re(yt, {
        key: s,
        name: o(V)(d[u.type]),
        css: o(R)
      }, {
        default: le(() => [
          d[u.type] ? (y(), re(Mt, {
            key: 0,
            items: i(u.type),
            "disabled-values": e.filters.times[u.type],
            "onUpdate:modelValue": (h) => j(u.type, h),
            onSelected: (h) => z(u.type),
            onToggle: (h) => z(u.type),
            onResetFlow: D[0] || (D[0] = (h) => M.$emit("reset-flow"))
          }, Ce({
            "button-icon": le(() => [
              M.$slots["clock-icon"] ? W(M.$slots, "clock-icon", { key: 0 }) : $("", !0),
              M.$slots["clock-icon"] ? $("", !0) : (y(), re(o(Un), { key: 1 }))
            ]),
            _: 2
          }, [
            M.$slots[`${u.type}-overlay`] ? {
              name: "item",
              fn: le(({ item: h }) => [
                W(M.$slots, `${u.type}-overlay`, {
                  text: h.text,
                  value: h.value
                })
              ]),
              key: "0"
            } : void 0
          ]), 1032, ["items", "disabled-values", "onUpdate:modelValue", "onSelected", "onToggle"])) : $("", !0)
        ]),
        _: 2
      }, 1032, ["name", "css"]))), 128))
    ]));
  }
}), wt = [
  { name: "clock-icon", use: ["time", "calendar"] },
  { name: "arrow-left", use: ["month-year", "calendar"] },
  { name: "arrow-right", use: ["month-year", "calendar"] },
  { name: "arrow-up", use: ["time", "calendar"] },
  { name: "arrow-down", use: ["time", "calendar"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar"] },
  { name: "day", use: ["calendar"] },
  { name: "month-overlay", use: ["calendar", "month-year"] },
  { name: "year-overlay", use: ["calendar", "month-year"] },
  { name: "hours-overlay", use: ["calendar", "time"] },
  { name: "minutes-overlay", use: ["calendar", "time"] },
  { name: "seconds-overlay", use: ["calendar", "time"] },
  { name: "hours", use: ["calendar", "time"] },
  { name: "minutes", use: ["calendar", "time"] },
  { name: "month", use: ["calendar", "month-year"] },
  { name: "year", use: ["calendar", "month-year"] },
  { name: "action-select", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar"] },
  { name: "marker-tooltip", use: ["calendar"] },
  { name: "now-button", use: [] },
  { name: "time-picker-overlay", use: ["calendar", "time"] },
  { name: "am-pm-button", use: ["calendar", "time"] }
], Nr = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], Ir = {
  all: () => wt,
  monthYear: () => wt.filter((e) => e.use.includes("month-year")),
  input: () => Nr,
  timePicker: () => wt.filter((e) => e.use.includes("time")),
  action: () => wt.filter((e) => e.use.includes("action")),
  calendar: () => wt.filter((e) => e.use.includes("calendar"))
}, at = (e, a) => {
  const n = [];
  return Ir[a]().forEach((t) => {
    e[t.name] && n.push(t.name);
  }), n;
}, Yr = ["aria-label"], Er = { class: "dp__overlay_container dp__container_flex" }, Fr = {
  key: 1,
  class: "dp__overlay_row"
}, Hr = ["aria-label"], Wr = /* @__PURE__ */ Oe({
  __name: "TimePicker",
  props: {
    ...xn,
    range: { type: Boolean, default: !1 },
    filters: { type: Object, default: () => ({}) },
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    customProps: { type: Object, default: null },
    modelAuto: { type: Boolean, default: !1 },
    internalModelValue: { type: [Date, Array], default: null }
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-closed"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, d = fn(), m = B(null), p = B(null), v = ye(pn, !1), g = B([]), w = B(null), V = ye(Xe), R = ye(qe), { transitionName: E, showTransition: N } = Ut(), { buildMatrix: G, setTimePicker: T } = Je();
    Ne(() => {
      n("mount"), !t.timePicker && (R == null ? void 0 : R.value) ? G([ke(m.value)], "time") : T(!0, t.timePicker);
    });
    const x = C(() => t.range && t.modelAuto ? oa(t.internalModelValue) : !0), l = B(!1), i = (D) => ({
      hours: Array.isArray(t.hours) ? t.hours[D] : t.hours,
      minutes: Array.isArray(t.minutes) ? t.minutes[D] : t.minutes,
      seconds: Array.isArray(t.seconds) ? t.seconds[D] : t.seconds
    }), Y = C(() => {
      const D = [];
      if (t.range)
        for (let u = 0; u < 2; u++)
          D.push(i(u));
      else
        D.push(i(0));
      return D;
    }), z = (D, u = !1, s = "") => {
      u || n("reset-flow"), l.value = D, R != null && R.value && (T(D), D || n("overlay-closed")), At(() => {
        s !== "" && g.value[0] && g.value[0].openChildCmp(s);
      });
    }, P = C(() => ({
      dp__button: !0,
      dp__button_bottom: v
    })), K = at(d, "timePicker"), X = (D, u, s) => t.range ? u === 0 ? [D, Y.value[1][s]] : [Y.value[0][s], D] : D, ee = (D) => {
      n("update:hours", D);
    }, Z = (D) => {
      n("update:minutes", D);
    }, j = (D) => {
      n("update:seconds", D);
    }, M = () => {
      w.value && (R == null ? void 0 : R.value) && w.value.focus({ preventScroll: !0 });
    };
    return a({ toggleTimePicker: z }), (D, u) => (y(), A("div", null, [
      D.timePicker ? $("", !0) : (y(), A("div", {
        key: 0,
        class: fe(o(P)),
        role: "button",
        "aria-label": o(V).openTimePicker,
        tabindex: "0",
        ref_key: "openTimePickerBtn",
        ref: m,
        onKeydown: [
          u[0] || (u[0] = ne((s) => z(!0), ["enter"])),
          u[1] || (u[1] = ne((s) => z(!0), ["space"]))
        ],
        onClick: u[2] || (u[2] = (s) => z(!0))
      }, [
        D.$slots["clock-icon"] ? W(D.$slots, "clock-icon", { key: 0 }) : $("", !0),
        D.$slots["clock-icon"] ? $("", !0) : (y(), re(o(Un), { key: 1 }))
      ], 42, Yr)),
      ze(yt, {
        name: o(E)(l.value),
        css: o(N)
      }, {
        default: le(() => [
          l.value || D.timePicker ? (y(), A("div", {
            key: 0,
            class: "dp__overlay",
            ref_key: "overlayRef",
            ref: w,
            tabindex: "0"
          }, [
            L("div", Er, [
              D.$slots["time-picker-overlay"] ? W(D.$slots, "time-picker-overlay", {
                key: 0,
                range: e.range,
                hours: e.hours,
                minutes: e.minutes,
                seconds: e.seconds,
                setHours: ee,
                setMinutes: Z,
                setSeconds: j
              }) : $("", !0),
              D.$slots["time-picker-overlay"] ? $("", !0) : (y(), A("div", Fr, [
                (y(!0), A(ie, null, pe(o(Y), (s, h) => Da((y(), re(Or, Pe({
                  key: h,
                  disabled: h === 0 ? D.fixedStart : D.fixedEnd,
                  hours: s.hours,
                  minutes: s.minutes,
                  seconds: s.seconds,
                  filters: e.filters,
                  ref_for: !0,
                  ref_key: "timeInputRefs",
                  ref: g
                }, {
                  is24: D.is24,
                  hoursGridIncrement: D.hoursGridIncrement,
                  minutesGridIncrement: D.minutesGridIncrement,
                  secondsGridIncrement: D.secondsGridIncrement,
                  hoursIncrement: D.hoursIncrement,
                  minutesIncrement: D.minutesIncrement,
                  secondsIncrement: D.secondsIncrement,
                  filters: e.filters,
                  noHoursOverlay: D.noHoursOverlay,
                  noMinutesOverlay: D.noMinutesOverlay,
                  noSecondsOverlay: D.noSecondsOverlay,
                  enableSeconds: D.enableSeconds,
                  closeTimePickerBtn: p.value,
                  order: h
                }, {
                  "onUpdate:hours": (F) => ee(X(F, h, "hours")),
                  "onUpdate:minutes": (F) => Z(X(F, h, "minutes")),
                  "onUpdate:seconds": (F) => j(X(F, h, "seconds")),
                  onMounted: M,
                  onOverlayClosed: M
                }), Ce({ _: 2 }, [
                  pe(o(K), (F, J) => ({
                    name: F,
                    fn: le((I) => [
                      W(D.$slots, F, Ge(nt(I)))
                    ])
                  }))
                ]), 1040, ["disabled", "hours", "minutes", "seconds", "filters", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                  [Ma, h === 0 ? !0 : o(x)]
                ])), 128))
              ])),
              D.timePicker ? $("", !0) : (y(), A("div", {
                key: 2,
                ref_key: "closeTimePickerBtn",
                ref: p,
                class: fe(o(P)),
                role: "button",
                "aria-label": o(V).closeTimePicker,
                tabindex: "0",
                onKeydown: [
                  u[3] || (u[3] = ne((s) => z(!1), ["enter"])),
                  u[4] || (u[4] = ne((s) => z(!1), ["space"]))
                ],
                onClick: u[5] || (u[5] = (s) => z(!1))
              }, [
                D.$slots["calendar-icon"] ? W(D.$slots, "calendar-icon", { key: 0 }) : $("", !0),
                D.$slots["calendar-icon"] ? $("", !0) : (y(), re(o(Wt), { key: 1 }))
              ], 42, Hr))
            ])
          ], 512)) : $("", !0)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ]));
  }
}), Kr = (e, a, n, t) => {
  const d = B(new Date()), m = B(), p = B([{ month: ve(new Date()), year: ue(new Date()) }]), v = B(
    e.range ? [_e(new Date()), _e(new Date())] : _e(new Date())
  ), g = B(
    e.range ? [Be(new Date()), Be(new Date())] : Be(new Date())
  ), w = B(e.range ? [0, 0] : 0);
  St(
    p,
    () => {
      setTimeout(() => {
        e.openOnTop && a("dpOpen");
      }, 0);
    },
    { deep: !0 }
  ), Ne(() => {
    Z(!0), l.value || (e.startDate && (p.value[0].month = ve(new Date(e.startDate)), p.value[0].year = ue(new Date(e.startDate)), e.multiCalendars && _(0)), e.startTime && x());
  });
  const V = C(
    () => (r) => p.value[r] ? p.value[r].month : 0
  ), R = C(
    () => (r) => p.value[r] ? p.value[r].year : 0
  ), E = (r, b, S) => {
    p.value[r].month = b, p.value[r].year = S;
  }, N = (r, b) => p.value[r].month = b, G = (r, b) => p.value[r].year = b, T = (r = !0) => e.enableSeconds ? Array.isArray(w.value) ? r ? w.value[0] : w.value[1] : w.value : 0, x = () => {
    e.startTime && (Wl(e.startTime) ? (v.value = [+e.startTime[0].hours, +e.startTime[1].hours], g.value = [+e.startTime[0].minutes, +e.startTime[1].minutes], e.enableSeconds && (w.value = [+e.startTime[0].seconds, +e.startTime[1].seconds])) : (v.value = +e.startTime.hours, g.value = +e.startTime.minutes, e.enableSeconds && (w.value = +e.startTime.seconds)));
  }, l = C({
    get: () => e.internalModelValue,
    set: (r) => {
      !e.readonly && !e.disabled && a("update:internalModelValue", r);
    }
  });
  St(l, () => Z());
  const i = (r) => {
    const { validate: b } = qn(
      e.minDate,
      e.maxDate,
      e.disabledDates,
      e.allowedDates,
      e.filters,
      e.disabledWeekDays,
      e.yearRange
    );
    return !b(r);
  }, Y = (r) => !l.value || e.hideOffsetDates && !r.current ? !1 : e.range ? e.modelAuto && Array.isArray(l.value) ? ce(r.value, l.value[0] ? l.value[0] : d.value) : !1 : e.multiDates && Array.isArray(l.value) ? l.value.some((b) => ce(b, r.value)) : ce(r.value, l.value ? l.value : d.value), z = (r) => zn(l.value, m.value, r.value), P = (r, b = !1) => {
    if ((!e.multiCalendars || !e.multiStatic || b) && (N(0, ve(r)), G(0, ue(r))), e.multiCalendars)
      for (let S = 1; S <= e.multiCalendars; S++) {
        const se = Me(new Date(), { month: V.value(S - 1), year: R.value(S - 1) }), Se = Wn(se, { months: 1 });
        p.value[S] = { month: ve(Se), year: ue(Se) };
      }
  }, K = () => {
    if (Array.isArray(l.value) && l.value.length === 2) {
      const r = new Date(l.value[1] ? l.value[1] : rt(l.value[0], 1)), [b, S] = [ve(l.value[0]), ue(l.value[0])], [se, Se] = [ve(l.value[1]), ue(l.value[1])];
      (b !== se || b === se && S !== Se) && e.multiCalendarsSolo && (N(1, ve(r)), G(1, ue(r)));
    }
  }, X = (r) => {
    P(r), v.value = _e(r), g.value = Be(r), w.value = je(r);
  }, ee = () => Array.isArray(l.value) && l.value.length ? l.value[l.value.length - 1] : null, Z = (r = !1) => {
    if (l.value)
      if (bt(l.value)) {
        if (l.value.length === 2 && !e.multiDates)
          P(l.value[0], r), v.value = [
            _e(l.value[0]),
            l.value[1] ? _e(l.value[1]) : _e(new Date())
          ], g.value = [
            Be(l.value[0]),
            l.value[1] ? Be(l.value[1]) : Be(new Date())
          ], w.value = [
            je(l.value[0]),
            l.value[1] ? je(l.value[1]) : je(new Date())
          ];
        else if (bt(l.value) && e.multiDates) {
          const b = l.value[l.value.length - 1];
          b && X(b);
        }
        e.multiCalendars && e.multiCalendarsSolo && K();
      } else
        X(l.value);
    else
      e.timePicker ? (x(), e.range ? Ve(v.value) && Ve(g.value) && (l.value = [
        Ae(new Date(), v.value[0], g.value[0], T()),
        Ae(new Date(), v.value[1], g.value[1], T(!1))
      ]) : l.value = Ae(
        new Date(),
        v.value,
        g.value,
        T()
      )) : e.monthPicker && !e.range ? l.value = st(new Date(), V.value(0), R.value(0)) : e.multiCalendars ? P(new Date()) : e.yearPicker && !e.range && (l.value = new Date());
  }, j = (r) => {
    const b = ve(new Date(r)), S = ue(new Date(r));
    if (N(0, b), G(0, S), e.multiCalendars > 0)
      for (let se = 1; se < e.multiCalendars; se++) {
        const Se = Ml(
          Me(new Date(r), { year: V.value(se - 1), month: R.value(se - 1) })
        );
        N(se, Se.month), G(se, Se.year);
      }
  }, M = (r) => {
    if (l.value && Array.isArray(l.value))
      if (l.value.some((b) => ce(r, b))) {
        const b = l.value.filter((S) => !ce(S, r));
        l.value = b.length ? b : null;
      } else
        (e.multiDatesLimit && +e.multiDatesLimit > l.value.length || !e.multiDatesLimit) && l.value.push(r);
    else
      l.value = [r];
  }, D = (r) => {
    if (Array.isArray(l.value) && l.value[0]) {
      const b = Ia(r, l.value[0]), S = De(l.value[0], r) ? r : l.value[0], se = De(r, l.value[0]) ? r : l.value[0], xe = An({ start: S, end: se }).filter((dt) => i(dt)).length, Te = Math.abs(b < 0 ? b + 1 : b - 1) - xe;
      if (e.minRange && e.maxRange)
        return Te >= +e.minRange && Te <= +e.maxRange;
      if (e.minRange)
        return Te >= +e.minRange;
      if (e.maxRange)
        return Te <= +e.maxRange;
    }
    return !0;
  }, u = (r) => Array.isArray(l.value) && l.value.length === 2 ? e.fixedStart && (De(r, l.value[0]) || ce(r, l.value[0])) ? [l.value[0], r] : e.fixedEnd && (we(r, l.value[1]) || ce(r, l.value[1])) ? [r, l.value[1]] : l.value : [], s = () => {
    e.autoApply && a("autoApply");
  }, h = (r) => !An({ start: r[0], end: r[1] }).some((S) => i(S)), F = (r, b = !1) => {
    if (!i(r.value) && !(!r.current && e.hideOffsetDates)) {
      if (e.weekPicker)
        return l.value = Rt(new Date(r.value), +e.weekStart), s();
      if (!e.range && !Ve(v.value) && !Ve(g.value)) {
        const S = Ae(new Date(r.value), v.value, g.value, T());
        e.multiDates ? M(S) : l.value = S, n(), s();
      } else if (Ve(v.value) && Ve(g.value) && !e.multiDates) {
        let S = l.value ? l.value.slice() : [];
        if (S.length === 2 && !(e.fixedStart || e.fixedEnd) && (S = []), e.autoRange) {
          const se = [new Date(r.value), $t(new Date(r.value), +e.autoRange)];
          h(se) && (b && j(r.value), S = se);
        } else
          e.fixedStart || e.fixedEnd ? S = u(new Date(r.value)) : S[0] ? D(new Date(r.value)) && (we(new Date(r.value), new Date(S[0])) ? S.unshift(new Date(r.value)) : S[1] = new Date(r.value)) : S[0] = new Date(r.value);
        S.length && (S[0] && !S[1] ? S[0] = Ae(S[0], v.value[0], g.value[0], T()) : (S[0] = Ae(S[0], v.value[0], g.value[0], T()), S[1] = Ae(S[1], v.value[1], g.value[1], T(!1)), n()), l.value = S, S[0] && S[1] && e.autoApply && a("autoApply"));
      }
    }
  }, J = (r) => {
    const b = r.find((S) => S.current);
    return b ? Na(b.value) : "";
  }, I = (r) => {
    !r.current && e.hideOffsetDates || (m.value = r.value);
  }, oe = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (m.value) {
        if (e.hideOffsetDates && !r.current)
          return !1;
        const b = $t(m.value, +e.autoRange), S = Rt(new Date(m.value), +e.weekStart);
        return e.weekPicker ? ce(S[1], new Date(r.value)) : ce(b, new Date(r.value));
      }
      return !1;
    }
    return !1;
  }, te = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (m.value) {
        const b = $t(m.value, +e.autoRange);
        if (e.hideOffsetDates && !r.current)
          return !1;
        const S = Rt(new Date(m.value), +e.weekStart);
        return e.weekPicker ? De(r.value, S[0]) && we(r.value, S[1]) : De(r.value, m.value) && we(r.value, b);
      }
      return !1;
    }
    return !1;
  }, k = (r) => {
    if (e.autoRange || e.weekPicker) {
      if (m.value) {
        if (e.hideOffsetDates && !r.current)
          return !1;
        const b = Rt(new Date(m.value), +e.weekStart);
        return e.weekPicker ? ce(b[0], r.value) : ce(m.value, r.value);
      }
      return !1;
    }
    return !1;
  }, _ = (r) => {
    for (let b = r - 1; b >= 0; b--) {
      const S = Dt(Me(new Date(), { month: V.value(b + 1), year: R.value(b + 1) }), 1);
      E(b, ve(S), ue(S));
    }
    for (let b = r + 1; b <= e.multiCalendars - 1; b++) {
      const S = rt(Me(new Date(), { month: V.value(b - 1), year: R.value(b - 1) }), 1);
      E(b, ve(S), ue(S));
    }
  }, O = (r) => st(new Date(), V.value(r), R.value(r)), Re = (r, b) => {
    if (N(r, b.month), G(r, b.year), e.multiCalendars && !e.multiCalendarsSolo && _(r), e.monthPicker || e.yearPicker)
      if (e.range) {
        let S = l.value ? l.value.slice() : [];
        S.length === 2 && S[1] !== null && (S = []), S.length ? we(O(r), S[0]) ? S.unshift(O(r)) : S[1] = O(r) : S = [O(r)], l.value = S;
      } else
        l.value = O(r);
    n(), a("updateMonthYear", { instance: r, month: b.month, year: b.year }), Pt(e.multiCalendarsSolo ? r : void 0);
  }, Ie = (r) => Ae(r, v.value, g.value, T()), Ye = (r) => {
    bt(r) && bt(l.value) && Ve(v.value) && Ve(g.value) ? (r[0] && l.value[0] && (l.value[0] = Ae(r[0], v.value[0], g.value[0], T())), r[1] && l.value[1] && (l.value[1] = Ae(
      r[1],
      v.value[1],
      g.value[1],
      T(!1)
    ))) : e.multiDates && Array.isArray(l.value) ? l.value[l.value.length - 1] = Ie(r) : !e.range && !Yt(r) && (l.value = Ie(r)), a("timeUpdate");
  }, Ke = (r, b = !0, S = !1) => {
    const se = b ? r : v.value, Se = !b && !S ? r : g.value, xe = S ? r : w.value;
    if (e.range && Yt(l.value) && Ve(se) && Ve(Se) && Ve(xe) && !e.disableTimeRangeValidation) {
      const Te = (Le) => Ae(l.value[Le], se[Le], Se[Le], xe[Le]), dt = (Le) => mn(l.value[Le], 0);
      if (ce(l.value[0], l.value[1]) && (vn(Te(0), dt(1)) || yn(Te(1), dt(0))))
        return;
    }
    if (v.value = se, g.value = Se, w.value = xe, l.value)
      if (e.multiDates) {
        const Te = ee();
        Te && Ye(Te);
      } else
        Ye(l.value);
    else
      e.timePicker && Ye(e.range ? [new Date(), new Date()] : new Date());
    n();
  }, Ue = () => {
    m.value = null;
  }, Ze = (r) => Bn(l.value, e.range) && l.value[0] && m.value ? r ? De(m.value, l.value[0]) : we(m.value, l.value[0]) : !0, be = (r, b = !0) => (e.range || e.weekPicker) && Yt(l.value) ? e.hideOffsetDates && !r.current ? !1 : ce(new Date(r.value), l.value[b ? 0 : 1]) : e.range ? ce(
    new Date(r.value),
    l.value && Array.isArray(l.value) ? b ? l.value[0] || null : l.value[1] : null
  ) && (b ? !we(
    m.value || null,
    Array.isArray(l.value) ? l.value[0] : null
  ) : !0) || ce(r.value, Array.isArray(l.value) ? l.value[0] : null) && Ze(b) : !1, it = (r, b) => Array.isArray(e.internalModelValue) && e.internalModelValue.length || e.weekPicker ? !1 : !r && !Y(b) && !(!b.current && e.hideOffsetDates) && (e.range ? !be(b) && !be(b, !1) : !0), pt = (r, b, S) => Array.isArray(e.internalModelValue) && e.internalModelValue[0] && e.internalModelValue.length === 1 ? r ? !1 : S ? De(e.internalModelValue[0], b.value) : we(e.internalModelValue[0], b.value) : !1, ht = (r = !1) => {
    e.autoApply && (e.monthPicker || e.yearPicker) && At().then(() => {
      e.range ? a("autoApply", r || !l.value || l.value.length === 1) : a("autoApply", r);
    });
  }, c = (r, b) => {
    const S = Me(new Date(), { month: V.value(b), year: R.value(b) }), se = r < 0 ? rt(S, 1) : Dt(S, 1);
    ia(
      e.minDate,
      e.maxDate,
      ve(se),
      ue(se),
      r < 0,
      e.preventMinMaxNavigation
    ) && (E(b, ve(se), ue(se)), e.multiCalendars && !e.multiCalendarsSolo && _(b), Pt());
  }, ae = (r, b) => {
    e.monthChangeOnScroll && c(e.monthChangeOnScroll !== "inverse" ? -r.deltaY : r.deltaY, b);
  }, me = (r, b, S = !1) => {
    e.monthChangeOnArrows && e.vertical === S && ut(r, b);
  }, ut = (r, b) => {
    c(r === "right" ? -1 : 1, b);
  }, Qe = (r) => e.markers.find((b) => ce(Ee(r.value), Ee(b.date))), Lt = () => {
    e.range ? Bn(l.value, e.range) && (l.value && l.value[0] ? l.value = we(new Date(), l.value[0]) ? [new Date(), l.value[0]] : [l.value[0], new Date()] : l.value = [new Date()]) : a("update:internalModelValue", new Date()), e.autoApply && a("selectDate");
  }, Gt = (r) => {
    r.length && r.length <= 2 && e.range && (l.value = r.map((b) => new Date(b)), e.autoApply && a("selectDate"));
  }, Pt = (r) => {
    r || r === 0 ? t.value[r].triggerTransition(V.value(r), R.value(r)) : t.value.forEach((b, S) => b.triggerTransition(V.value(S), R.value(S)));
  };
  return {
    today: d,
    hours: v,
    minutes: g,
    seconds: w,
    month: V,
    year: R,
    monthYearSelect: ht,
    isDisabled: i,
    updateTime: Ke,
    setHoverDate: I,
    getWeekNum: J,
    selectDate: F,
    rangeActive: z,
    isActiveDate: Y,
    updateMonthYear: Re,
    isHoverRangeEnd: oe,
    isAutoRangeInBetween: te,
    isAutoRangeStart: k,
    clearHoverDate: Ue,
    rangeActiveStartEnd: be,
    handleScroll: ae,
    getMarker: Qe,
    handleArrow: me,
    handleSwipe: ut,
    selectCurrentDate: Lt,
    isHoverDate: it,
    isHoverDateStartEnd: pt,
    presetDateRange: Gt
  };
}, _t = Ht({
  menuFocused: !1,
  shiftKeyInMenu: !1
}), ua = () => ({
  setMenuFocused: (t) => {
    _t.menuFocused = t;
  },
  getStore: () => _t,
  setShiftKey: (t) => {
    _t.shiftKeyInMenu !== t && (_t.shiftKeyInMenu = t);
  }
});
var Et = /* @__PURE__ */ ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(Et || {});
const Ur = ["id", "aria-label", "onKeydown"], Lr = {
  key: 0,
  class: "dp__preset_ranges"
}, Gr = ["onClick"], jr = {
  key: 1,
  class: "dp__now_wrap"
}, zr = /* @__PURE__ */ Oe({
  __name: "DatepickerMenu",
  props: {
    ...la,
    ...gn,
    ...hn,
    internalModelValue: { type: [Date, Array], default: null },
    multiCalendars: { type: Number, default: 0 },
    openOnTop: { type: Boolean, default: !1 }
  },
  emits: [
    "update:internalModelValue",
    "closePicker",
    "selectDate",
    "dpOpen",
    "autoApply",
    "timeUpdate",
    "flow-step",
    "updateMonthYear",
    "invalid-select"
  ],
  setup(e, { emit: a }) {
    const n = e, t = fn(), d = B(null), m = Ht({
      timePicker: !!(!n.enableTimePicker || n.timePicker || n.monthPicker),
      monthYearInput: !!n.timePicker,
      calendar: !1
    }), p = B([]), v = B([]), g = B(null), w = B(null), V = B(0), R = B(!1), E = B(0), N = ye(Kt), G = ye(Xe), T = ye(qe), { setMenuFocused: x, setShiftKey: l, getStore: i } = ua();
    Ne(() => {
      var U;
      R.value = !0, (U = n.presetRanges) != null && U.length || se();
      const f = ke(w);
      if (f && !n.textInput && !n.inline && (x(!0), X()), f) {
        const H = (q) => {
          !n.monthYearComponent && !n.timePickerComponent && q.preventDefault(), q.stopImmediatePropagation(), q.stopPropagation();
        };
        f.addEventListener("pointerdown", H), f.addEventListener("mousedown", H);
      }
      document.addEventListener("resize", se);
    }), cn(() => {
      document.removeEventListener("resize", se);
    });
    const { arrowRight: Y, arrowLeft: z, arrowDown: P, arrowUp: K } = Je(), X = () => {
      const f = ke(w);
      f && f.focus({ preventScroll: !0 });
    }, ee = () => {
      var f;
      ((f = n.flow) == null ? void 0 : f.length) && E.value !== -1 && (E.value += 1, a("flow-step", E.value), bn());
    }, Z = () => {
      E.value = -1;
    }, {
      updateTime: j,
      updateMonthYear: M,
      today: D,
      month: u,
      year: s,
      hours: h,
      minutes: F,
      seconds: J,
      isDisabled: I,
      isActiveDate: oe,
      selectDate: te,
      getWeekNum: k,
      setHoverDate: _,
      isHoverRangeEnd: O,
      isAutoRangeInBetween: Re,
      isAutoRangeStart: Ie,
      rangeActive: Ye,
      clearHoverDate: Ke,
      rangeActiveStartEnd: Ue,
      monthYearSelect: Ze,
      handleScroll: be,
      handleArrow: it,
      handleSwipe: pt,
      getMarker: ht,
      selectCurrentDate: c,
      isHoverDateStartEnd: ae,
      isHoverDate: me,
      presetDateRange: ut
    } = Kr(n, a, ee, v), Qe = at(t, "calendar"), Lt = at(t, "action"), Gt = at(t, "timePicker"), Pt = at(t, "monthYear"), r = C(() => n.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), b = C(() => zl(n.yearRange)), S = C(() => Xl(n.locale, n.monthNameFormat)), se = () => {
      const f = ke(d);
      f && (V.value = f.getBoundingClientRect().width);
    }, Se = C(
      () => (f) => Ll(
        u.value(f),
        s.value(f),
        +n.weekStart,
        n.hideOffsetDates
      )
    ), xe = C(
      () => n.multiCalendars > 0 && n.range ? [...Array(n.multiCalendars).keys()] : [0]
    ), Te = C(
      () => (f) => f === 1
    ), dt = C(() => n.monthPicker || n.timePicker || n.yearPicker), Le = C(
      () => ({
        dp__flex_display: n.multiCalendars > 0
      })
    ), ca = C(() => ({
      dp__instance_calendar: n.multiCalendars > 0
    })), fa = C(() => ({
      dp__menu_disabled: n.disabled,
      dp__menu_readonly: n.readonly
    })), ma = C(
      () => (f) => ha(Se, f)
    ), va = C(() => ({
      locale: n.locale,
      weekNumName: n.weekNumName,
      weekStart: n.weekStart,
      weekNumbers: n.weekNumbers,
      customProps: n.customProps,
      calendarClassName: n.calendarClassName,
      specificMode: dt.value,
      getWeekNum: k,
      multiCalendars: n.multiCalendars,
      modeHeight: n.modeHeight,
      internalModelValue: n.internalModelValue,
      noSwipe: n.noSwipe,
      vertical: n.vertical,
      dayNames: n.dayNames,
      monthChangeOnScroll: n.monthChangeOnScroll
    })), ya = C(
      () => ({
        dp__menu: !0,
        dp__menu_index: !n.inline,
        dp__relative: n.inline,
        [n.menuClassName]: !!n.menuClassName
      })
    ), pa = () => n.modelAuto && Array.isArray(n.internalModelValue) ? !!n.internalModelValue[0] : !1, gt = () => n.modelAuto ? oa(n.internalModelValue) : !0, ha = (f, U) => f.value(U).map((H) => ({
      ...H,
      days: H.days.map((q) => {
        const Q = I(q.value), kt = me(Q, q), et = n.range ? n.modelAuto ? pa() && oe(q) : !1 : oe(q), $n = n.highlight ? Xn(q.value, n.highlight) : !1, Dn = n.highlightWeekDays && n.highlightWeekDays.includes(q.value.getDay()), Mn = (n.range || n.weekPicker) && (n.multiCalendars > 0 ? q.current : !0) && !Q && gt() && !(!q.current && n.hideOffsetDates) && !oe(q) ? Ye(q) : !1;
        return q.marker = ht(q), q.classData = {
          dp__cell_offset: !q.current,
          dp__pointer: !Q && !(!q.current && n.hideOffsetDates),
          dp__active_date: et,
          dp__date_hover: kt,
          dp__date_hover_start: ae(kt, q, !0),
          dp__date_hover_end: ae(kt, q, !1),
          dp__range_between: Mn && !n.weekPicker,
          dp__range_between_week: Mn && n.weekPicker,
          dp__today: !n.noToday && ce(q.value, D.value) && q.current,
          dp__cell_disabled: Q,
          dp__cell_auto_range: Re(q),
          dp__cell_auto_range_start: Ie(q),
          dp__cell_auto_range_end: O(q),
          dp__range_start: n.multiCalendars > 0 ? q.current && Ue(q) && gt() : Ue(q) && gt(),
          dp__range_end: n.multiCalendars > 0 ? q.current && Ue(q, !1) && gt() : Ue(q, !1) && gt(),
          [n.calendarCellClassName]: !!n.calendarCellClassName,
          dp__cell_highlight: ($n || Dn) && !et,
          dp__cell_highlight_active: ($n || Dn) && et
        }, q;
      })
    })), ga = (f) => {
      f.stopPropagation(), f.preventDefault(), f.stopImmediatePropagation();
    }, ka = () => {
      n.escClose && a("closePicker");
    }, wa = (f, U = !1) => {
      te(f, U), n.spaceConfirm && a("selectDate");
    }, jt = (f) => {
      var U;
      (U = n.flow) != null && U.length && (m[f] = !0, Object.keys(m).filter((H) => !m[H]).length || bn());
    }, bn = () => {
      n.flow[E.value] === "month" && p.value[0] && p.value[0].toggleMonthPicker(!0), n.flow[E.value] === "year" && p.value && p.value[0].toggleYearPicker(!0), n.flow[E.value] === "calendar" && g.value && g.value.toggleTimePicker(!1, !0), n.flow[E.value] === "time" && g.value && g.value.toggleTimePicker(!0, !0);
      const f = n.flow[E.value];
      (f === "hours" || f === "minutes" || f === "seconds") && g.value && g.value.toggleTimePicker(!0, !0, f);
    }, Ct = (f) => {
      if (T != null && T.value) {
        if (f === "up")
          return K();
        if (f === "down")
          return P();
        if (f === "left")
          return z();
        if (f === "right")
          return Y();
      } else
        f === "left" || f === "up" ? it("left", 0, f === "up") : it("right", 0, f === "down");
    }, ba = (f) => {
      l(f.shiftKey), !n.disableMonthYearSelect && f.code === "Tab" && f.target.classList.contains("dp__menu") && i().shiftKeyInMenu && (f.preventDefault(), f.stopImmediatePropagation(), a("closePicker"));
    };
    return (f, U) => (y(), re(yt, {
      appear: "",
      name: o(N).menuAppear,
      mode: "out-in",
      css: !!o(N)
    }, {
      default: le(() => [
        L("div", {
          id: f.uid ? `dp-menu-${f.uid}` : void 0,
          tabindex: "0",
          ref_key: "dpMenuRef",
          ref: w,
          role: "dialog",
          "aria-label": o(G).menu,
          class: fe(o(ya)),
          onMouseleave: U[12] || (U[12] = (...H) => o(Ke) && o(Ke)(...H)),
          onClick: ga,
          onKeydown: [
            ne(ka, ["esc"]),
            U[13] || (U[13] = ne(He((H) => Ct("left"), ["prevent"]), ["left"])),
            U[14] || (U[14] = ne(He((H) => Ct("up"), ["prevent"]), ["up"])),
            U[15] || (U[15] = ne(He((H) => Ct("down"), ["prevent"]), ["down"])),
            U[16] || (U[16] = ne(He((H) => Ct("right"), ["prevent"]), ["right"])),
            ba
          ]
        }, [
          (f.disabled || f.readonly) && f.inline ? (y(), A("div", {
            key: 0,
            class: fe(o(fa))
          }, null, 2)) : $("", !0),
          !f.inline && !f.teleportCenter ? (y(), A("div", {
            key: 1,
            class: fe(o(r))
          }, null, 2)) : $("", !0),
          L("div", {
            class: fe(f.presetRanges.length ? "dp__menu_content_wrapper" : null)
          }, [
            f.presetRanges.length ? (y(), A("div", Lr, [
              (y(!0), A(ie, null, pe(f.presetRanges, (H, q) => (y(), A("div", {
                key: q,
                style: mt(H.style || {}),
                class: "dp__preset_range",
                onClick: (Q) => o(ut)(H.range)
              }, ge(H.label), 13, Gr))), 128))
            ])) : $("", !0),
            L("div", {
              class: "dp__instance_calendar",
              ref_key: "calendarWrapperRef",
              ref: d,
              role: "document"
            }, [
              L("div", {
                class: fe(o(Le))
              }, [
                (y(!0), A(ie, null, pe(o(xe), (H, q) => (y(), A("div", {
                  key: H,
                  class: fe(o(ca))
                }, [
                  !f.disableMonthYearSelect && !f.timePicker ? (y(), re(Bt(f.monthYearComponent ? f.monthYearComponent : Ar), Pe({
                    key: 0,
                    ref_for: !0,
                    ref: (Q) => {
                      Q && (p.value[q] = Q);
                    }
                  }, {
                    months: o(S),
                    years: o(b),
                    filters: f.filters,
                    monthPicker: f.monthPicker,
                    month: o(u)(H),
                    year: o(s)(H),
                    customProps: f.customProps,
                    multiCalendars: e.multiCalendars,
                    multiCalendarsSolo: f.multiCalendarsSolo,
                    instance: H,
                    minDate: f.minDate,
                    maxDate: f.maxDate,
                    preventMinMaxNavigation: f.preventMinMaxNavigation,
                    internalModelValue: e.internalModelValue,
                    range: f.range,
                    reverseYears: f.reverseYears,
                    vertical: f.vertical,
                    yearPicker: f.yearPicker
                  }, {
                    onMount: U[0] || (U[0] = (Q) => jt("monthYearInput")),
                    onResetFlow: Z,
                    onUpdateMonthYear: (Q) => o(M)(H, Q),
                    onMonthYearSelect: o(Ze),
                    onOverlayClosed: X
                  }), Ce({ _: 2 }, [
                    pe(o(Pt), (Q, kt) => ({
                      name: Q,
                      fn: le((et) => [
                        W(f.$slots, Q, Ge(nt(et)))
                      ])
                    }))
                  ]), 1040, ["onUpdateMonthYear", "onMonthYearSelect"])) : $("", !0),
                  ze(vr, Pe({
                    ref_for: !0,
                    ref: (Q) => {
                      Q && (v.value[q] = Q);
                    }
                  }, o(va), {
                    "flow-step": E.value,
                    "onUpdate:flow-step": U[1] || (U[1] = (Q) => E.value = Q),
                    instance: H,
                    "mapped-dates": o(ma)(H),
                    month: o(u)(H),
                    year: o(s)(H),
                    onSelectDate: (Q) => o(te)(Q, !o(Te)(H)),
                    onHandleSpace: (Q) => wa(Q, !o(Te)(H)),
                    onSetHoverDate: U[2] || (U[2] = (Q) => o(_)(Q)),
                    onHandleScroll: (Q) => o(be)(Q, H),
                    onHandleSwipe: (Q) => o(pt)(Q, H),
                    onMount: U[3] || (U[3] = (Q) => jt("calendar")),
                    onResetFlow: Z
                  }), Ce({ _: 2 }, [
                    pe(o(Qe), (Q, kt) => ({
                      name: Q,
                      fn: le((et) => [
                        W(f.$slots, Q, Ge(nt({ ...et })))
                      ])
                    }))
                  ]), 1040, ["flow-step", "instance", "mapped-dates", "month", "year", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
                ], 2))), 128))
              ], 2),
              L("div", null, [
                f.enableTimePicker && !f.monthPicker && !f.weekPicker ? (y(), re(Bt(f.timePickerComponent ? f.timePickerComponent : Wr), Pe({
                  key: 0,
                  ref_key: "timePickerRef",
                  ref: g
                }, {
                  is24: f.is24,
                  hoursIncrement: f.hoursIncrement,
                  minutesIncrement: f.minutesIncrement,
                  hoursGridIncrement: f.hoursGridIncrement,
                  secondsIncrement: f.secondsIncrement,
                  minutesGridIncrement: f.minutesGridIncrement,
                  secondsGridIncrement: f.secondsGridIncrement,
                  noHoursOverlay: f.noHoursOverlay,
                  noMinutesOverlay: f.noMinutesOverlay,
                  noSecondsOverlay: f.noSecondsOverlay,
                  range: f.range,
                  filters: f.filters,
                  timePicker: f.timePicker,
                  hours: o(h),
                  minutes: o(F),
                  seconds: o(J),
                  customProps: f.customProps,
                  enableSeconds: f.enableSeconds,
                  fixedStart: f.fixedStart,
                  fixedEnd: f.fixedEnd,
                  modelAuto: f.modelAuto,
                  internalModelValue: e.internalModelValue
                }, {
                  onMount: U[4] || (U[4] = (H) => jt("timePicker")),
                  "onUpdate:hours": U[5] || (U[5] = (H) => o(j)(H)),
                  "onUpdate:minutes": U[6] || (U[6] = (H) => o(j)(H, !1)),
                  "onUpdate:seconds": U[7] || (U[7] = (H) => o(j)(H, !1, !0)),
                  onResetFlow: Z,
                  onOverlayClosed: X
                }), Ce({ _: 2 }, [
                  pe(o(Gt), (H, q) => ({
                    name: H,
                    fn: le((Q) => [
                      W(f.$slots, H, Ge(nt(Q)))
                    ])
                  }))
                ]), 1040)) : $("", !0)
              ])
            ], 512),
            f.showNowButton ? (y(), A("div", jr, [
              f.$slots["now-button"] ? W(f.$slots, "now-button", {
                key: 0,
                selectCurrentDate: o(c)
              }) : $("", !0),
              f.$slots["now-button"] ? $("", !0) : (y(), A("button", {
                key: 1,
                type: "button",
                role: "button",
                class: "dp__now_button",
                onClick: U[8] || (U[8] = (...H) => o(c) && o(c)(...H))
              }, ge(f.nowButtonLabel), 1))
            ])) : $("", !0)
          ], 2),
          !f.autoApply || f.keepActionRow ? (y(), re(Bt(f.actionRowComponent ? f.actionRowComponent : lr), Pe({ key: 2 }, {
            calendarWidth: V.value,
            selectText: f.selectText,
            cancelText: f.cancelText,
            internalModelValue: e.internalModelValue,
            range: f.range,
            previewFormat: f.previewFormat,
            inline: f.inline,
            monthPicker: f.monthPicker,
            timePicker: f.timePicker,
            customProps: f.customProps,
            multiCalendars: e.multiCalendars,
            menuMount: R.value,
            maxTime: f.maxTime,
            minTime: f.minTime,
            enableTimePicker: f.enableTimePicker,
            minDate: f.minDate,
            maxDate: f.maxDate,
            multiDates: f.multiDates,
            modelAuto: f.modelAuto,
            partialRange: f.partialRange,
            ignoreTimeValidation: f.ignoreTimeValidation
          }, {
            onClosePicker: U[9] || (U[9] = (H) => f.$emit("closePicker")),
            onSelectDate: U[10] || (U[10] = (H) => f.$emit("selectDate")),
            onInvalidSelect: U[11] || (U[11] = (H) => f.$emit("invalid-select"))
          }), Ce({ _: 2 }, [
            pe(o(Lt), (H, q) => ({
              name: H,
              fn: le((Q) => [
                W(f.$slots, H, Ge(nt({ ...Q })))
              ])
            }))
          ]), 1040)) : $("", !0)
        ], 42, Ur)
      ]),
      _: 3
    }, 8, ["name", "css"]));
  }
}), Xr = (e, a, n, t, d, m, p, v, g, w, V, R, E, N, G, T, x) => {
  const l = B(""), i = B();
  St(i, () => {
    x("internalModelChange", i.value);
  });
  const Y = (u) => [ee(u[0]), u[1] ? ee(u[1]) : null], z = (u) => {
    let s = null;
    u ? a ? Yl(u) && "hours" in u[0] && "minutes" in u[0] ? s = [
      Ae(null, +u[0].hours, +u[0].minutes, +u[0].seconds),
      Ae(null, +u[1].hours, +u[1].minutes, +u[1].seconds)
    ] : Il(u) && (s = Ae(null, +u.hours, +u.minutes, +u.seconds)) : n ? El(u) && "month" in u[0] && "year" in u[0] ? (s = [st(null, +u[0].month, +u[0].year)], u[1] ? s[1] = st(null, +u[1].month, +u[1].year) : !u[1] && d && (s[1] = null)) : Fl(u) && "month" in u && "year" in u && (s = st(null, +u.month, +u.year)) : E ? Array.isArray(u) ? s = [
      lt(new Date(), u[0]),
      !u[1] && d ? null : lt(new Date(), u[1])
    ] : s = lt(new Date(), u) : w && Array.isArray(u) ? s = u.map((h) => ee(h)) : R && Array.isArray(u) ? s = [new Date(u[0]), new Date(u[1])] : t ? T ? Array.isArray(u) ? s = Y(u) : s = [ee(u), null] : Hl(u, d) && (s = Y(u)) : Kl(u) && (s = ee(u)) : s = null, rn(s) ? (i.value = s, K()) : (i.value = null, l.value = "");
  }, P = () => jn(
    e,
    m,
    v,
    n,
    a,
    R,
    E,
    p
  ), K = () => {
    if (!i.value)
      l.value = "";
    else if (!e || typeof e == "string") {
      const u = P();
      Array.isArray(i.value) && w ? l.value = i.value.map((s) => vt(s, u, g == null ? void 0 : g.value)).join("; ") : l.value = vt(
        i.value,
        u,
        g == null ? void 0 : g.value,
        N == null ? void 0 : N.rangeSeparator,
        T
      );
    } else
      a ? l.value = e(sn(i.value)) : n ? l.value = e(Vn(i.value)) : l.value = e(i.value);
  }, X = () => i.value ? t ? d ? i.value.length >= 1 : i.value.length === 2 : !!i.value : !1, ee = (u) => {
    if (V) {
      const s = new Date(u);
      return V === "preserve" ? new Date(s.getTime() + s.getTimezoneOffset() * 6e4) : s;
    }
    return G ? G === "date" || G === "timestamp" ? new Date(u) : G === "format" && (typeof e == "string" || !e) ? ln(u, P(), new Date()) : ln(u, G, new Date()) : new Date(u);
  }, Z = (u) => G ? G === "timestamp" ? +u : G === "format" && (typeof e == "string" || !e) ? vt(u, P(), g == null ? void 0 : g.value, N == null ? void 0 : N.rangeSeparator) : vt(u, G, g == null ? void 0 : g.value, N == null ? void 0 : N.rangeSeparator) : u, j = (u) => {
    x("update:modelValue", u);
  }, M = () => [
    Z(i.value[0]),
    i.value[1] ? Z(i.value[1]) : null
  ];
  return {
    parseExternalModelValue: z,
    formatInputValue: K,
    internalModelValue: i,
    inputValue: l,
    emitModelValue: () => {
      if (n)
        j(Vn(i.value));
      else if (a)
        j(sn(i.value));
      else if (R)
        j(i.value);
      else if (E)
        j(
          Array.isArray(i.value) ? [
            ue(i.value[0]),
            i.value[1] ? ue(i.value[1]) : null
          ] : ue(i.value)
        );
      else {
        if (i.value && t && d && i.value.length === 1 && i.value.push(null), V) {
          let u;
          if (Array.isArray(i.value)) {
            const s = (h) => h && Zt(h, V === "preserve");
            T ? u = i.value[1] ? i.value.map(s) : Zt(i.value[0], V === "preserve") : u = i.value.map(s);
          } else
            u = Zt(i.value, V === "preserve");
          return j(u);
        }
        Array.isArray(i.value) && !w ? j(
          T ? i.value[1] ? M() : Z(i.value[0]) : M()
        ) : Array.isArray(i.value) && w ? j(i.value.map((u) => Z(u))) : j(Z(i.value));
      }
      K();
    },
    checkBeforeEmit: X
  };
}, qr = (e, a, n, t, d, m, p, v, g) => {
  const w = B({
    top: "0",
    left: "0",
    transform: "none"
  }), V = B(!1), R = 390, E = (P) => {
    const K = P.getBoundingClientRect();
    return {
      left: K.left + window.scrollX,
      top: K.top + window.scrollY
    };
  }, N = (P) => {
    const K = P.getBoundingClientRect();
    let X = 0, ee = 0;
    for (; P && !isNaN(P.offsetLeft) && !isNaN(P.offsetTop); )
      X += P.offsetLeft - P.scrollLeft, ee = K.top + P.scrollTop, P = P.offsetParent;
    return { top: ee, left: X };
  }, G = (P, K) => {
    w.value.left = `${P + K}px`, w.value.transform = "translateX(-100%)";
  }, T = (P) => {
    w.value.left = `${P}px`, w.value.transform = "translateX(0)";
  }, x = (P, K) => {
    e === Et.left && T(P), e === Et.right && G(P, K), e === Et.center && (w.value.left = `${P + K / 2}px`, w.value.transform = "translateX(-50%)");
  }, l = () => {
    const P = ke(d);
    if (P) {
      const K = window.innerHeight, { top: X } = a ? N(P) : E(P), { left: ee, width: Z, top: j, height: M } = P.getBoundingClientRect(), D = K - j - M;
      w.value.top = j > D ? `${X - R}px` : `${X}px`, x(ee, Z);
    }
  }, i = () => {
    w.value.left = "50%", w.value.top = "50%", w.value.transform = "translate(-50%, -50%)", w.value.position = "fixed";
  }, Y = (P = !0) => {
    if (!m) {
      if (v.value)
        return i();
      const K = ke(d);
      if (a && typeof a != "boolean")
        w.value = a(K);
      else if (K) {
        const { left: X, width: ee, height: Z } = K.getBoundingClientRect(), { top: j } = a ? N(K) : E(K);
        w.value.top = `${Z + j + +p}px`, x(X, ee), P && n && z();
      }
    }
  }, z = () => {
    const P = ke(d);
    if (P && n && !m) {
      const { height: K, top: X, left: ee, width: Z } = P.getBoundingClientRect(), { top: j } = a ? N(P) : E(P), D = window.innerHeight - X - K, u = ke(t);
      if (u) {
        const { height: s, left: h, right: F } = u.getBoundingClientRect(), J = s + K;
        J > X && J > D ? X < D ? (Y(!1), V.value = !1) : (w.value.top = `${j - s - +p}px`, V.value = !0) : J > D ? (w.value.top = `${j - s - +p}px`, V.value = !0) : (Y(!1), V.value = !1), h < 0 ? T(ee) : F > document.documentElement.clientWidth && G(ee, Z);
      }
    }
    g("recalculatePosition");
  };
  return { openOnTop: V, menuPosition: w, setMenuPosition: Y, setInitialPosition: l, recalculatePosition: z };
}, Jr = typeof window < "u" ? window : void 0, an = () => {
}, Zr = (e) => Sa() ? (Aa(e), !0) : !1, Qr = (e, a, n, t) => {
  if (!e)
    return an;
  let d = an;
  const m = St(
    () => o(e),
    (v) => {
      d(), v && (v.addEventListener(a, n, t), d = () => {
        v.removeEventListener(a, n, t), d = an;
      });
    },
    { immediate: !0, flush: "post" }
  ), p = () => {
    m(), d();
  };
  return Zr(p), p;
}, xr = (e, a, n, t = {}) => {
  const { window: d = Jr, event: m = "pointerdown" } = t;
  return d ? Qr(d, m, (v) => {
    const g = ke(e), w = ke(a);
    !g || !w || g === v.target || v.composedPath().includes(g) || v.composedPath().includes(w) || n(v);
  }, { passive: !0 }) : void 0;
}, es = /* @__PURE__ */ Oe({
  __name: "VueDatePicker",
  props: {
    ...Tl
  },
  emits: [
    "update:modelValue",
    "textSubmit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internalModelChange",
    "recalculatePosition",
    "flow-step",
    "updateMonthYear",
    "invalid-select"
  ],
  setup(e, { expose: a, emit: n }) {
    const t = e, d = fn(), m = B(!1), p = Tt(t, "modelValue"), v = B(null), g = B(null), w = Tt(t, "teleportCenter");
    ct(pn, t.autoApply);
    const V = C(() => t.formatLocale);
    ct(Zn, V), ct(Jn, Tt(t, "textInput")), ct(qe, Tt(t, "arrowNavigation")), Ne(() => {
      z(t.modelValue), t.inline || (window.addEventListener("scroll", k), window.addEventListener("resize", _)), t.inline && (m.value = !0);
    }), cn(() => {
      t.inline || (window.removeEventListener("scroll", k), window.removeEventListener("resize", _));
    });
    const R = at(d, "all"), E = at(d, "input");
    St(
      p,
      () => {
        z(p.value);
      },
      { deep: !0 }
    );
    const { openOnTop: N, menuPosition: G, setMenuPosition: T, recalculatePosition: x, setInitialPosition: l } = qr(
      t.position,
      t.altPosition,
      t.autoPosition,
      v,
      g,
      t.inline,
      t.offset,
      w,
      n
    ), {
      internalModelValue: i,
      inputValue: Y,
      parseExternalModelValue: z,
      emitModelValue: P,
      checkBeforeEmit: K,
      formatInputValue: X
    } = Xr(
      t.format,
      t.timePicker,
      t.monthPicker,
      t.range,
      t.partialRange,
      t.is24,
      t.enableTimePicker,
      t.enableSeconds,
      V,
      t.multiDates,
      t.utc,
      t.weekPicker,
      t.yearPicker,
      t.textInputOptions,
      t.modelType,
      t.modelAuto,
      n
    ), { clearArrowNav: ee } = Je(), { setMenuFocused: Z, setShiftKey: j } = ua(), M = C(
      () => ({
        dp__main: !0,
        dp__theme_dark: t.dark,
        dp__theme_light: !t.dark,
        dp__flex_display: t.inline,
        dp__flex_display_with_input: t.inlineWithInput
      })
    ), D = C(() => On(t.format) ? t.format : jn(
      null,
      t.is24,
      t.enableSeconds,
      t.monthPicker,
      t.timePicker,
      t.weekPicker,
      t.yearPicker,
      t.enableTimePicker
    )), u = C(() => t.previewFormat ? t.previewFormat : On(D.value) ? D.value : t.format), s = C(() => typeof t.transitions == "boolean" ? t.transitions ? Nn({}) : !1 : Nn(t.transitions));
    ct(Kt, s);
    const h = C(() => t.dark ? "dp__theme_dark" : "dp__theme_light"), F = C(() => Object.assign(Jl(), t.textInputOptions)), J = C(() => er(t.ariaLabels));
    ct(Xe, J);
    const I = C(() => Zl(t.filters)), oe = C(() => {
      const c = (ae) => {
        const me = {
          hours: _e(new Date()),
          minutes: Be(new Date()),
          seconds: je(new Date())
        };
        return Object.assign(me, ae);
      };
      return t.range ? t.startTime && Array.isArray(t.startTime) ? [c(t.startTime[0]), c(t.startTime[1])] : null : t.startTime && !Array.isArray(t.startTime) ? c(t.startTime) : null;
    }), te = C(() => t.multiCalendars === null ? 0 : typeof t.multiCalendars == "boolean" ? t.multiCalendars ? 2 : 0 : +t.multiCalendars >= 2 ? +t.multiCalendars : 2), k = () => {
      m.value && (t.closeOnScroll ? be() : t.autoPosition ? T() : window.removeEventListener("scroll", k));
    }, _ = () => {
      m.value && T();
    }, O = () => {
      !t.disabled && !t.readonly && (l(), m.value = !0, At().then(() => {
        T(), m.value && n("open");
      }), m.value || Ze(), z(t.modelValue));
    }, Re = () => {
      Y.value = "", Ze(), n("update:modelValue", null), n("cleared"), be();
    }, Ie = () => {
      const { validate: c } = qn(
        t.minDate,
        t.maxDate,
        t.disabledDates,
        t.allowedDates,
        I.value,
        t.disabledWeekDays,
        t.yearRange
      ), ae = i.value;
      return !ae || !Array.isArray(ae) && c(ae) ? !0 : Array.isArray(ae) ? ae.length === 2 && c(ae[0]) && c(ae[1]) ? !0 : !!c(ae[0]) : !1;
    }, Ye = () => {
      K() && Ie() ? (P(), be()) : n("invalid-select", i.value);
    }, Ke = (c) => {
      P(), t.closeOnAutoApply && !c && be();
    }, Ue = (c = !1) => {
      t.autoApply && (!t.enableTimePicker || t.monthPicker || t.yearPicker || t.ignoreTimeValidation ? !0 : on(i.value, t.maxTime, t.minTime, t.maxDate, t.minDate)) && Ie() && (t.range && Array.isArray(i.value) ? (t.partialRange || i.value.length === 2) && Ke(c) : Ke(c));
    }, Ze = () => {
      i.value = null;
    }, be = () => {
      t.inline || (m.value && (m.value = !1, Z(!1), j(!1), ee(), n("closed"), l(), Y.value && z(p.value)), Ze(), g.value && g.value.focusInput());
    }, it = (c, ae) => {
      if (!c) {
        i.value = null;
        return;
      }
      i.value = c, ae && (Ye(), n("textSubmit"));
    }, pt = () => {
      t.autoApply && on(i.value, t.maxTime, t.minTime, t.maxDate, t.minDate) && P();
    }, ht = () => m.value ? be() : O();
    return xr(v, g, be), a({
      closeMenu: be,
      selectDate: Ye,
      clearValue: Re,
      openMenu: O,
      onScroll: k,
      formatInputValue: X
    }), (c, ae) => (y(), A("div", {
      class: fe(o(M))
    }, [
      ze(Nl, Pe({
        ref_key: "inputRef",
        ref: g
      }, {
        placeholder: c.placeholder,
        hideInputIcon: c.hideInputIcon,
        readonly: c.readonly,
        disabled: c.disabled,
        inputClassName: c.inputClassName,
        clearable: c.clearable,
        state: c.state,
        inline: c.inline,
        inlineWithInput: c.inlineWithInput,
        textInput: c.textInput,
        textInputOptions: o(F),
        range: c.range,
        isMenuOpen: m.value,
        pattern: o(D),
        autoApply: c.autoApply,
        uid: c.uid,
        required: c.required,
        name: c.name,
        autocomplete: c.autocomplete
      }, {
        "input-value": o(Y),
        "onUpdate:input-value": ae[0] || (ae[0] = (me) => tt(Y) ? Y.value = me : null),
        onClear: Re,
        onOpen: O,
        onSetInputDate: it,
        onSetEmptyDate: o(P),
        onSelectDate: Ye,
        onToggle: ht,
        onClose: be,
        onFocus: ae[1] || (ae[1] = (me) => c.$emit("focus")),
        onBlur: ae[2] || (ae[2] = (me) => c.$emit("blur"))
      }), Ce({ _: 2 }, [
        pe(o(E), (me, ut) => ({
          name: me,
          fn: le((Qe) => [
            W(c.$slots, me, Ge(nt(Qe)))
          ])
        }))
      ]), 1040, ["input-value", "onSetEmptyDate"]),
      m.value ? (y(), re(Pa, {
        key: 0,
        to: c.teleport,
        disabled: c.inline
      }, [
        m.value ? (y(), re(zr, Pe({
          key: 0,
          ref_key: "dpMenuRef",
          ref: v,
          class: o(h),
          style: o(G)
        }, {
          weekNumbers: c.weekNumbers,
          weekStart: c.weekStart,
          disableMonthYearSelect: c.disableMonthYearSelect,
          menuClassName: c.menuClassName,
          calendarClassName: c.calendarClassName,
          yearRange: c.yearRange,
          range: c.range,
          multiCalendars: o(te),
          multiCalendarsSolo: c.multiCalendarsSolo,
          multiStatic: c.multiStatic,
          calendarCellClassName: c.calendarCellClassName,
          enableTimePicker: c.enableTimePicker,
          is24: c.is24,
          hoursIncrement: c.hoursIncrement,
          minutesIncrement: c.minutesIncrement,
          hoursGridIncrement: c.hoursGridIncrement,
          minutesGridIncrement: c.minutesGridIncrement,
          minDate: c.minDate,
          maxDate: c.maxDate,
          autoApply: c.autoApply,
          selectText: c.selectText,
          cancelText: c.cancelText,
          previewFormat: o(u),
          locale: c.locale,
          weekNumName: c.weekNumName,
          disabledDates: c.disabledDates,
          filters: o(I),
          minTime: c.minTime,
          maxTime: c.maxTime,
          inline: c.inline,
          openOnTop: o(N),
          monthPicker: c.monthPicker,
          timePicker: c.timePicker,
          monthNameFormat: c.monthNameFormat,
          startDate: c.startDate,
          startTime: o(oe),
          monthYearComponent: c.monthYearComponent,
          timePickerComponent: c.timePickerComponent,
          actionRowComponent: c.actionRowComponent,
          customProps: c.customProps,
          hideOffsetDates: c.hideOffsetDates,
          autoRange: c.autoRange,
          noToday: c.noToday,
          noHoursOverlay: c.noHoursOverlay,
          noMinutesOverlay: c.noMinutesOverlay,
          disabledWeekDays: c.disabledWeekDays,
          allowedDates: c.allowedDates,
          showNowButton: c.showNowButton,
          nowButtonLabel: c.nowButtonLabel,
          monthChangeOnScroll: c.monthChangeOnScroll,
          markers: c.markers,
          uid: c.uid,
          modeHeight: c.modeHeight,
          enableSeconds: c.enableSeconds,
          secondsIncrement: c.secondsIncrement,
          secondsGridIncrement: c.secondsGridIncrement,
          noSecondsOverlay: c.noSecondsOverlay,
          escClose: c.escClose,
          spaceConfirm: c.spaceConfirm,
          monthChangeOnArrows: c.monthChangeOnArrows,
          textInput: c.textInput,
          disabled: c.disabled,
          readonly: c.readonly,
          multiDates: c.multiDates,
          presetRanges: c.presetRanges,
          flow: c.flow,
          preventMinMaxNavigation: c.preventMinMaxNavigation,
          minRange: c.minRange,
          maxRange: c.maxRange,
          fixedStart: c.fixedStart,
          fixedEnd: c.fixedEnd,
          multiDatesLimit: c.multiDatesLimit,
          reverseYears: c.reverseYears,
          keepActionRow: c.keepActionRow,
          weekPicker: c.weekPicker,
          noSwipe: c.noSwipe,
          vertical: c.vertical,
          arrowNavigation: c.arrowNavigation,
          yearPicker: c.yearPicker,
          disableTimeRangeValidation: c.disableTimeRangeValidation,
          dayNames: c.dayNames,
          modelAuto: c.modelAuto,
          highlight: c.highlight,
          highlightWeekDays: c.highlightWeekDays,
          partialRange: c.partialRange,
          teleportCenter: c.teleportCenter,
          ignoreTimeValidation: c.ignoreTimeValidation
        }, {
          internalModelValue: o(i),
          "onUpdate:internalModelValue": ae[3] || (ae[3] = (me) => tt(i) ? i.value = me : null),
          onClosePicker: be,
          onSelectDate: Ye,
          onDpOpen: o(x),
          onAutoApply: Ue,
          onTimeUpdate: pt,
          onFlowStep: ae[4] || (ae[4] = (me) => c.$emit("flow-step", me)),
          onUpdateMonthYear: ae[5] || (ae[5] = (me) => c.$emit("updateMonthYear", me)),
          onInvalidSelect: ae[6] || (ae[6] = (me) => c.$emit("invalid-select", o(i)))
        }), Ce({ _: 2 }, [
          pe(o(R), (me, ut) => ({
            name: me,
            fn: le((Qe) => [
              W(c.$slots, me, Ge(nt({ ...Qe })))
            ])
          }))
        ]), 1040, ["class", "style", "internalModelValue", "onDpOpen"])) : $("", !0)
      ], 8, ["to", "disabled"])) : $("", !0)
    ], 2));
  }
}), da = /* @__PURE__ */ (() => {
  const e = es;
  return e.install = (a) => {
    a.component("Vue3DatePicker", e);
  }, e;
})(), ts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: da
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(ts).forEach(([e, a]) => {
  e !== "default" && (da[e] = a);
});
export {
  da as default
};
